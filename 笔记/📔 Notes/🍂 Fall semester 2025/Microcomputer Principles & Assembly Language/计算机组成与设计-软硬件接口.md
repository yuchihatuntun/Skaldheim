### 指令(Instruction)：计算机的语言

要想控制计算机的硬件，就必须使用它能听懂的语言。

- **指令 (Instruction)**：计算机语言中的每一个“单词”，就是一个指令。每个指令都对应一个硬件能够执行的具体操作。

- **指令系统 (Instruction Set)**：计算机语言的“词汇表”，也就是计算机硬件能够理解和执行的所有指令的集合。指令系统是被一个给定体系结构所理解的命令词汇表。

<span style="background:rgba(163, 218, 252, 0.55)">一旦学会了一种计算机语言（指令系统），再去学习其他的就会变得非常容易，因为它们底层的设计思想和结构都是相通的</span>。

**本书介绍的指令系统实例**：

1. **RISC-V (主角)**：

    这是一个相对较新的指令系统，于2010年初由加州大学伯克利分校开发，设计简洁、现代且开放，非常适合教学。

2. **MIPS (对比参照一)**：

    它被认为是设计于20世纪80年代的经典指令系统范例。RISC-V 在很多设计上都与 MIPS 遵循了类似的原则。

3. **Intel x86 (对比参照二)**：

    这是我们最常见到的指令系统，起源于20世纪70年代。它在今天的个人电脑（PC）以及云端服务器中仍然占据着统治地位。

> [!note] 指令系统为什么都那么相似？
>
> 全世界那么多计算机，它们的指令系统（计算机语言）都大同小异？原因有两点：
>
> - **基于共同的硬件原理**：所有计算机都是基于相似的基本硬件技术构建的，并且都包含一些共同的核心部件（如处理器、存储器等）。“身体构造”类似，那么指挥它们的“语言”自然也会很像。
>
> - **追求共同的设计目标**：所有的计算机设计师都在努力实现一个共同的目标，这个目标从计算机诞生之初到现在从未改变，那就是——找到一种理想的硬件和软件的“交界面”（即指令系统），这个交界面要能让计算机性能最大化，同时成本最小化。

> [!note] 衡量指令系统的“黄金法则” (源自1947年的远见)
>
> 选择一个好的指令系统，主要看三个“实用性”因素：
>
> 1. **硬件简单性**：这个指令系统是否易于用简单的硬件来实现？
> 2. **应用清晰度**：用它来描述和解决实际问题时，逻辑是否清晰？
> 3. **处理速度**：用它来解决这些问题时，速度是否够快？
>
> 即使到了今天，“硬件简单性”这个考量因素，和在20世纪50年代时一样至关重要。

基于以上背景，本章的目标就是详细阐述这个贯穿始终的设计思想。具体来说：

1. **指令系统如何在硬件中表示**：揭示计算机底层的“0和1”是如何代表具体指令的。

2. **指令系统与高级语言的关系**：解释我们编写的C语言或Java这样的高级语言代码，最终是如何一步步翻译成计算机能懂的指令的。我们会用C语言作为示例，并会展示面向对象的语言（如Java）会带来怎样的变化。

**指令系统预览**：

1. **RISC-V的操作数 (Operands) - 计算机处理的对象**

    在学习任何语言时，我们首先要知道它能操作哪些“东西”。在RISC-V中，这些“东西”就是操作数。主要分为两类：**寄存器和存储器**。

    |名字|示例|注解|
    | ---- | ---- | ---- |
    |32个寄存器|`x0～x31`|CPU内部的“高速暂存区”或“草稿纸”。它们离计算核心非常近，访问速度极快。在RISC-V中，只对在寄存器中的数据执行算术运算|
    |2⁶¹个存储字|`Memory[0], Memory[8], …, Memory[18446744073709551608]`|只能被数据传输指令访问。RISC-V使用字节寻址，因此顺序双字访问相差8。存储器保存数据结构、数组和换出的寄存器的内容|

    >[!danger] 核心规则
    >
    > 1. 在RISC-V中，**所有算术运算（加、减、乘、除等）都只能在寄存器中进行**。也就是说，想计算两个数，必须先把它们从别处（主要是存储器）拿到寄存器里，计算出结果后，结果也存放在寄存器里。
    > 2. 存储器只能通过特定的数据传输指令（后面会讲）来访问。你不能直接对存储器里的数据做加法。

    寄存器是CPU的工作台，存储器是仓库。要加工零件（数据），必须先把零件从仓库搬到工作台上，加工完再决定是放回仓库还是继续留在工作台上。

2. **RISC-V汇编语言指令 - 计算机执行的动作**

    |类别|指令|示例|含义|注解|
    | ---- | ---- | ---- | ---- | ---- |
    |算术运算|加|`add x5, x6, x7`|`x5 = x6 + x7`|三寄存器操作数；加|
    |算术运算|减|`sub x5, x6, x7`|`x5 = x6 - x7`|三寄存器操作数；减|
    |算术运算|立即数加|`addi x5, x6, 20`|`x5 = x6 + 20`|用于加常数|
    |数据传输|取双字|`ld x5, 40(x6)`|x5 = Memory[x6 + 40]|从存储器取双字到寄存器|
    |数据传输|存双字|sd x5, 40(x6)|Memory[x6 + 40] = x5|从寄存器存双字到存储器|
    |数据传输|取字|lw x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取字到寄存器|
    |数据传输|取字（无符号数）|lwu x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取无符号字到寄存器|
    |数据传输|存字|sw x5, 40(x6)|Memory[x6 + 40] = x5|从寄存器存字到存储器|
    |数据传输|取半字|lh x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取半字到寄存器|
    |数据传输|取半字（无符号数）|lhu x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取无符号半字到寄存器|
    |数据传输|存半字|sh x5, 40(x6)|Memory[x6 + 40] = x5|从寄存器存半字到存储器|
    |数据传输|取字节|lb x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取字节到寄存器|
    |数据传输|取字节（无符号数）|lbu x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取无符号字节到寄存器|
    |数据传输|存字节|sb x5, 40(x6)|Memory[x6 + 40] = x5|从寄存器存字节到存储器|
    |数据传输|取保留字|lr.d x5, (x6)|x5 = Memory[x6]|取；原子交换的前半部分|
    |数据传输|存条件字|sc.d x7, x5, (x6)|Memory[x6] = x5; x7 = 0/1|存；原子交换的后半部分|
    |数据传输|取立即数高位|lui x5, 0x12345|x5 = 0x12345000|取左移12位后的20位立即数|
    |逻辑运算|与|and x5, x6, x7|x5 = x6 & x7|三寄存器操作数；按位与|
    |逻辑运算|或|or x5, x6, x8|x5 = x6 | x8|三寄存器操作数；按位或|
    |逻辑运算|异或|xor x5, x6, x9|x5 = x6 ^ x9|三寄存器操作数；按位异或|
    |逻辑运算|与立即数|andi x5, x6, 20|x5 = x6 & 20|寄存器与常数按位与|
    |逻辑运算|或立即数|ori x5, x6, 20|x5 = x6 | 20|寄存器与常数按位或|
    |逻辑运算|异或立即数|xori x5, x6, 20|x5 = x6 ^ 20|寄存器与常数按位异或|
    |移位操作|逻辑左移|sll x5, x6, x7|x5 = x6 << x7|按寄存器给定位数左移|
    |移位操作|逻辑右移|srl x5, x6, x7|x5 = x6 >> x7|按寄存器给定位数右移|
    |移位操作|算术右移|sra x5, x6, x7|x5 = x6 >> x7|按寄存器给定位数算术右移|
    |移位操作|逻辑左移立即数|slli x5, x6, 3|x5 = x6 << 3|根据立即数给定位数左移|
    |移位操作|逻辑右移立即数|srli x5, x6, 3|x5 = x6 >> 3|根据立即数给定位数右移|
    |移位操作|算术右移立即数|srai x5, x6, 3|x5 = x6 >> 3|根据立即数给定位数算术右移|
    |条件分支|相等即跳转|beq x5, x6, 100|if (x5 == x6) go to PC+100|若寄存器数值相等则跳转到PC相对地址|
    |条件分支|不等即跳转|bne x5, x6, 100|if (x5 != x6) go to PC+100|若寄存器数值不等则跳转到PC相对地址|
    |条件分支|小于即跳转|blt x5, x6, 100|if (x5 < x6) go to PC+100|若寄存器数值比较结果小于则跳转到PC相对地址|
    |条件分支|大于等于即跳转|bge x5, x6, 100|if (x5 >= x6) go to PC+100|若寄存器数值比较结果大于或等于则跳转到PC相对地址|
    |条件分支|小于即跳转（无符号）|bltu x5, x6, 100|if (x5 < x6) go to PC+100|若寄存器数值比较结果小于则跳转到PC相对地址（无符号）|
    |条件分支|大于等于即跳转（无符号）|bgeu x5, x6, 100|if (x5 >= x6) go to PC+100|若寄存器数值比较结果大于或等于则跳转到PC相对地址（无符号）|
    |无条件跳转|跳转 - 链接|jal x1, 100|x1 = PC+4; go to PC+100|用于PC相关的过程调用|
    |无条件跳转|跳转 - 链接（寄存器地址）|jalr x1, 100(x5)|x1 = PC+4; go to x5+100|用于过程返回；非直接调用|


#### 2-1 计算机硬件的操作

