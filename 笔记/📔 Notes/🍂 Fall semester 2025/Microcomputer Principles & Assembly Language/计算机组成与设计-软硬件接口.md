### 指令(Instruction)：计算机的语言

要想控制计算机的硬件，就必须使用它能听懂的语言。

- **指令 (Instruction)**：计算机语言中的每一个“单词”，就是一个指令。每个指令都对应一个硬件能够执行的具体操作。

- **指令系统 (Instruction Set)**：计算机语言的“词汇表”，也就是计算机硬件能够理解和执行的所有指令的集合。指令系统是被一个给定体系结构所理解的命令词汇表。

<span style="background:rgba(163, 218, 252, 0.55)">一旦学会了一种计算机语言（指令系统），再去学习其他的就会变得非常容易，因为它们底层的设计思想和结构都是相通的</span>。

**本书介绍的指令系统实例**：

1. **RISC-V (主角)**：

    这是一个相对较新的指令系统，于2010年初由加州大学伯克利分校开发，设计简洁、现代且开放，非常适合教学。

2. **MIPS (对比参照一)**：

    它被认为是设计于20世纪80年代的经典指令系统范例。RISC-V 在很多设计上都与 MIPS 遵循了类似的原则。

3. **Intel x86 (对比参照二)**：

    这是我们最常见到的指令系统，起源于20世纪70年代。它在今天的个人电脑（PC）以及云端服务器中仍然占据着统治地位。

> [!note] 指令系统为什么都那么相似？
>
> 全世界那么多计算机，它们的指令系统（计算机语言）都大同小异？原因有两点：
>
> - **基于共同的硬件原理**：所有计算机都是基于相似的基本硬件技术构建的，并且都包含一些共同的核心部件（如处理器、存储器等）。“身体构造”类似，那么指挥它们的“语言”自然也会很像。
>
> - **追求共同的设计目标**：所有的计算机设计师都在努力实现一个共同的目标，这个目标从计算机诞生之初到现在从未改变，那就是——找到一种理想的硬件和软件的“交界面”（即指令系统），这个交界面要能让计算机性能最大化，同时成本最小化。

> [!note] 衡量指令系统的“黄金法则” (源自1947年的远见)
>
> 选择一个好的指令系统，主要看三个“实用性”因素：
>
> 1. **硬件简单性**：这个指令系统是否易于用简单的硬件来实现？
> 2. **应用清晰度**：用它来描述和解决实际问题时，逻辑是否清晰？
> 3. **处理速度**：用它来解决这些问题时，速度是否够快？
>
> 即使到了今天，“硬件简单性”这个考量因素，和在20世纪50年代时一样至关重要。

基于以上背景，本章的目标就是详细阐述这个贯穿始终的设计思想。具体来说：

1. **指令系统如何在硬件中表示**：揭示计算机底层的“0和1”是如何代表具体指令的。

2. **指令系统与高级语言的关系**：解释我们编写的C语言或Java这样的高级语言代码，最终是如何一步步翻译成计算机能懂的指令的。我们会用C语言作为示例，并会展示面向对象的语言（如Java）会带来怎样的变化。

**指令系统预览**：

1. **RISC-V的操作数 (Operands) - 计算机处理的对象**

    在学习任何语言时，我们首先要知道它能操作哪些“东西”。在RISC-V中，这些“东西”就是操作数。主要分为两类：**寄存器和存储器**。

    |名字|示例|注解|
    | ---- | ---- | ---- |
    |32个寄存器|`x0～x31`|CPU内部的“高速暂存区”或“草稿纸”。它们离计算核心非常近，访问速度极快。在RISC-V中，只对在寄存器中的数据执行算术运算|
    |2⁶¹个存储字|`Memory[0], Memory[8], …, Memory[18446744073709551608]`|只能被数据传输指令访问。RISC-V使用字节寻址，因此顺序双字访问相差8。存储器保存数据结构、数组和换出的寄存器的内容|

    >[!danger] 核心规则
    >
    > 1. 在RISC-V中，**所有算术运算（加、减、乘、除等）都只能在寄存器中进行**。也就是说，想计算两个数，必须先把它们从别处（主要是存储器）拿到寄存器里，计算出结果后，结果也存放在寄存器里。
    > 2. 存储器只能通过特定的数据传输指令（后面会讲）来访问。你不能直接对存储器里的数据做加法。

    寄存器是CPU的工作台，存储器是仓库。要加工零件（数据），必须先把零件从仓库搬到工作台上，加工完再决定是放回仓库还是继续留在工作台上。

2. **RISC-V汇编语言指令 - 计算机执行的动作**

    |类别|指令|示例|含义|注解|
    | ---- | ---- | ---- | ---- | ---- |
    |算术运算|加|`add x5, x6, x7`|`x5 = x6 + x7`|三寄存器操作数；加|
    |算术运算|减|`sub x5, x6, x7`|`x5 = x6 - x7`|三寄存器操作数；减|
    |算术运算|立即数加|`addi x5, x6, 20`|`x5 = x6 + 20`|用于加常数|
    |数据传输|取双字|`ld x5, 40(x6)`|x5 = Memory[x6 + 40]|从存储器取双字到寄存器|
    |数据传输|存双字|sd x5, 40(x6)|Memory[x6 + 40] = x5|从寄存器存双字到存储器|
    |数据传输|取字|lw x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取字到寄存器|
    |数据传输|取字（无符号数）|lwu x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取无符号字到寄存器|
    |数据传输|存字|sw x5, 40(x6)|Memory[x6 + 40] = x5|从寄存器存字到存储器|
    |数据传输|取半字|lh x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取半字到寄存器|
    |数据传输|取半字（无符号数）|lhu x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取无符号半字到寄存器|
    |数据传输|存半字|sh x5, 40(x6)|Memory[x6 + 40] = x5|从寄存器存半字到存储器|
    |数据传输|取字节|lb x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取字节到寄存器|
    |数据传输|取字节（无符号数）|lbu x5, 40(x6)|x5 = Memory[x6 + 40]|从存储器取无符号字节到寄存器|
    |数据传输|存字节|sb x5, 40(x6)|Memory[x6 + 40] = x5|从寄存器存字节到存储器|
    |数据传输|取保留字|lr.d x5, (x6)|x5 = Memory[x6]|取；原子交换的前半部分|
    |数据传输|存条件字|sc.d x7, x5, (x6)|Memory[x6] = x5; x7 = 0/1|存；原子交换的后半部分|
    |数据传输|取立即数高位|lui x5, 0x12345|x5 = 0x12345000|取左移12位后的20位立即数|
    |逻辑运算|与|and x5, x6, x7|x5 = x6 & x7|三寄存器操作数；按位与|
    |逻辑运算|或|or x5, x6, x8|x5 = x6 | x8|三寄存器操作数；按位或|
    |逻辑运算|异或|xor x5, x6, x9|x5 = x6 ^ x9|三寄存器操作数；按位异或|
    |逻辑运算|与立即数|andi x5, x6, 20|x5 = x6 & 20|寄存器与常数按位与|
    |逻辑运算|或立即数|ori x5, x6, 20|x5 = x6 | 20|寄存器与常数按位或|
    |逻辑运算|异或立即数|xori x5, x6, 20|x5 = x6 ^ 20|寄存器与常数按位异或|
    |移位操作|逻辑左移|sll x5, x6, x7|x5 = x6 << x7|按寄存器给定位数左移|
    |移位操作|逻辑右移|srl x5, x6, x7|x5 = x6 >> x7|按寄存器给定位数右移|
    |移位操作|算术右移|sra x5, x6, x7|x5 = x6 >> x7|按寄存器给定位数算术右移|
    |移位操作|逻辑左移立即数|slli x5, x6, 3|x5 = x6 << 3|根据立即数给定位数左移|
    |移位操作|逻辑右移立即数|srli x5, x6, 3|x5 = x6 >> 3|根据立即数给定位数右移|
    |移位操作|算术右移立即数|srai x5, x6, 3|x5 = x6 >> 3|根据立即数给定位数算术右移|
    |条件分支|相等即跳转|beq x5, x6, 100|if (x5 == x6) go to PC+100|若寄存器数值相等则跳转到PC相对地址|
    |条件分支|不等即跳转|bne x5, x6, 100|if (x5 != x6) go to PC+100|若寄存器数值不等则跳转到PC相对地址|
    |条件分支|小于即跳转|blt x5, x6, 100|if (x5 < x6) go to PC+100|若寄存器数值比较结果小于则跳转到PC相对地址|
    |条件分支|大于等于即跳转|bge x5, x6, 100|if (x5 >= x6) go to PC+100|若寄存器数值比较结果大于或等于则跳转到PC相对地址|
    |条件分支|小于即跳转（无符号）|bltu x5, x6, 100|if (x5 < x6) go to PC+100|若寄存器数值比较结果小于则跳转到PC相对地址（无符号）|
    |条件分支|大于等于即跳转（无符号）|bgeu x5, x6, 100|if (x5 >= x6) go to PC+100|若寄存器数值比较结果大于或等于则跳转到PC相对地址（无符号）|
    |无条件跳转|跳转 - 链接|jal x1, 100|x1 = PC+4; go to PC+100|用于PC相关的过程调用|
    |无条件跳转|跳转 - 链接（寄存器地址）|`jalr x1, 100(x5)`|x1 = PC+4; go to x5+100|用于过程返回；非直接调用|


#### 2-2 计算机硬件的操作

“**每台计算机都必须能够实现算术运算。**” 这是计算机存在的基础，没有计算能力，计算机将一事无成。


```asm
add a, b, c
```

这条指令非常直白，它告诉计算机执行一个加法操作。具体意思是：把变量 `b` 和变量 `c` 的值相加，再将得到的总和存放到变量 `a` 中。

> [!note] 设计原则：简洁与固定
>
> RISC-V算术指令的一个核心设计哲学——格式固定。这个原则包含两条严格的规定：
>
> - **一个指令只做一个操作**：一条 add 指令只能执行一次加法，不能同时做别的事情。
>
> - **一个指令只有三个变量**：算术指令必须不多不少，正好包含三个操作数（一个目标，两个源）。

> [!note] 举例说明：如何计算四个变量相加？
>
> 将复杂的任务分解成多个简单的、符合格式的步骤。
>
> ```asm
> add a, b, c       // The sum of b and c is placed in a
> add a, a, d       // The sum of b, c, and d is now in a
> add a, a, e       // The sum of b, c, d, and e is now in a
> ```
>
> 这个例子展示了RISC-V的设计思想：用一系列简单、统一、快速的指令，来组合完成复杂的任务。 这种设计使得硬件实现起来更简单，执行效率也更高。

> [!note] 例题1：简单的C语句编译 (一对一翻译)
>
> 这段C程序代码包含五个变量a、b、c、d和e。由于Java是从C发展而来的,所以本例以及接下来若干示例都适用于这两种高级编程语言:
>
> ```c
> a = b + c;
> d = a - e;
> ```
>
> 编译器将C语言转换成RISC-V汇编指令。写出编译器生成的RISC-V代码。

> [!warning] 例题1答案
>
> RISC-V指令对两个源操作数进行操作,并将结果放人一个目标操作数。因此,上面的两条简单语句直接编译成以下两条RISC-V汇编指令。
>
> ```asm
> add a, b, c
> sub d, a, e
> ```

> [!note] 例题2：复杂的C语句编译 (分解任务)
>
> 有一条包含五个变量`f`、`g`、`h`、`i`和`j`的复杂语句:
>
> ```c
> f = (g + h) - (i + j);
> ```
>
> C编译器可能产生什么样的RISC-V汇编指令?

> [!note] 例题2答案
>
> ```asm
> add t0, g, h    // t0 = g + h
> add t1, i, j    // t1 = i + j
> sub f, t0, t1   // f = t0 - t1
> ```

> [!note] Java 的跨平台兼容性
>
> Java 从诞生之初，最大的追求就是“可移植性”，也就是我们常说的“一次编写，到处运行”。程序员用 Java 写好程序后，不用为每个不同的操作系统（Windows, macOS, Linux）或不同的CPU架构（Intel x86, ARM, RISC-V）重新修改和编译。
>
> **早期方案**：为了实现这个目标，Java 设计了一种不依赖于任何具体硬件的中间语言——**Java 字节码 (bytecode)**。
>
> 每个需要运行Java程序的平台（Windows, macOS等），都会安装一个对应的**JVM（Java虚拟机）**。当Java程序运行时，JVM会逐行地读取Java字节码，然后把它“翻译”成当前平台硬件能听懂的机器指令（比如RISC-V指令）并立即执行。
>
> - **优点**：因为有了JVM这个中间层，Java程序本身（字节码）就可以完全不用关心底层是什么硬件和系统，从而实现了跨平台。
> - **缺点**：性能较低。同声传译（解释执行）是一边翻译一边说，速度肯定比直接阅读一篇已经翻译好的稿子（编译执行）要慢。因此，早期Java程序的性能远不如C语言这种直接编译成机器码的程序。
>
> **现代方案**：为了解决解释执行带来的性能问题，现代的Java系统引入了一项关键技术——**JIT编译器**
>
> JIT编译器是JVM的一部分，它比简单的解释器要智能得多。它会在Java程序正在运行的过程中，监控哪些代码是“**热点代码**”（被频繁执行的代码）。
>
> 一旦识别出这些热点代码，JIT编译器就会在运行时，把这些部分的Java字节码直接编译成当前硬件平台最高效的本地机器指令（例如RISC-V指令）。编译完成后，这部分代码就会被缓存起来。
>
> 下次再执行到这段代码时，JVM就不用再去逐行解释了，而是直接运行已经编译好的、速度飞快的本地机器码。这就使得Java的性能能够大大提升，甚至接近于等效的C程序。
>
> **为什么叫“即时 (Just-In-Time)”？**
>
> 它强调了编译发生的时间点。
>
> - **C语言**：采用的是“提前编译”（Ahead-Of-Time, AOT）。在程序运行之前，你就已经把所有源代码一次性编译成了机器码文件（如 .exe 文件）。
> - **Java (JIT)**：编译发生在程序运行之中，是在代码即将被执行的“那一刻”或“正需要时”（Just In Time）才进行编译。这比C语言的编译要“晚得多”。

#### 2-3 计算机硬件的操作数

- 在高级编程语言（如C或Java）里，我们可以随心所欲地定义很多变量。

- 但在硬件层面，执行指令时所需的数据（即操作数）不能随意存放，它们必须被预先放置在CPU内部几个**有限的、特殊的位置**。

在RISC-V中，寄存器的大小通常是**64位**。

> [!note] 操作数单位术语
>
> 双字 (doubleword)：右侧的注释框解释道，在RISC-V中，一个64位的基本访问单位被称为“双字”。因此，这64位的寄存器正好存放一个“双字”。
>
> 字 (word)：另一个常见的单位是32位，被称为“字”。（在32位架构中，寄存器就是32位的“字”。）

数量：RISC-V 体系结构中，可供程序员使用的通用寄存器数量是 **32** 个。

为什么寄存器数量要限制在32个？：

1. **更少则更快 (Smaller is faster)**

    1. **物理距离问题**：寄存器是物理存在的电子元件。如果寄存器的数量非常多（比如几百个），那么这些元件在芯片上占据的物理面积就会更大。

    2. **信号传播延迟**：当CPU需要从某个寄存器中读取数据时，电信号需要从一个地方传播到另一个地方。寄存器越多，排布得越分散，信号需要传播的物理距离就越远。

    3. **影响时钟周期**：信号传播是需要时间的。距离越远，所需时间就越长。而CPU的时钟周期（可以理解为CPU做一步最基本操作所需的时间）必须长到足以让最慢的信号也能传播到位。因此，寄存器太多会导致信号传播时间变长，进而被迫延长时钟周期，最终导致整个CPU的运行频率变慢。

    当然，这个原则不是绝对的，“31个寄存器不一定就比32个快”。但它揭示了一个根本性的**权衡（trade-off）**：设计师必须在“程序员希望有更多寄存器可用”和“硬件追求更快的时钟速度”之间找到一个最佳平衡点。32个，就是当前被广泛接受的一个甜点。

2. **指令格式的位数限制**

指令本身是用二进制编码的。指令中需要有特定的位数来指明用的是哪个寄存器。例如，要从32个寄存器中选一个，需要用$\log_{2}32 = 5$个比特位来编码。如果寄存器数量增加到64个，就需要6个比特位。指令的总长度是有限的，分给寄存器编号的位数越多，留给其他功能（如表示操作类型、立即数等）的位数就越少。因此，指令格式本身也限制了寄存器的数量。


