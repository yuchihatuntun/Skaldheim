### 指令(Instruction)：计算机的语言

要想控制计算机的硬件，就必须使用它能听懂的语言。

- **指令 (Instruction)**：计算机语言中的每一个“单词”，就是一个指令。每个指令都对应一个硬件能够执行的具体操作。

- **指令系统 (Instruction Set)**：计算机语言的“词汇表”，也就是计算机硬件能够理解和执行的所有指令的集合。指令系统是被一个给定体系结构所理解的命令词汇表。

<span style="background:rgba(163, 218, 252, 0.55)">一旦学会了一种计算机语言（指令系统），再去学习其他的就会变得非常容易，因为它们底层的设计思想和结构都是相通的</span>。

**本书介绍的指令系统实例**：

1. **RISC-V (主角)**：

    这是一个相对较新的指令系统，于2010年初由加州大学伯克利分校开发，设计简洁、现代且开放，非常适合教学。

2. **MIPS (对比参照一)**：

    它被认为是设计于20世纪80年代的经典指令系统范例。RISC-V 在很多设计上都与 MIPS 遵循了类似的原则。

3. **Intel x86 (对比参照二)**：

    这是我们最常见到的指令系统，起源于20世纪70年代。它在今天的个人电脑（PC）以及云端服务器中仍然占据着统治地位。

> [!note] 指令系统为什么都那么相似？
>
> 全世界那么多计算机，它们的指令系统（计算机语言）都大同小异？原因有两点：
>
> - **基于共同的硬件原理**：所有计算机都是基于相似的基本硬件技术构建的，并且都包含一些共同的核心部件（如处理器、存储器等）。“身体构造”类似，那么指挥它们的“语言”自然也会很像。
>
> - **追求共同的设计目标**：所有的计算机设计师都在努力实现一个共同的目标，这个目标从计算机诞生之初到现在从未改变，那就是——找到一种理想的硬件和软件的“交界面”（即指令系统），这个交界面要能让计算机性能最大化，同时成本最小化。

> [!note] 衡量指令系统的“黄金法则” (源自1947年的远见)
>
> 选择一个好的指令系统，主要看三个“实用性”因素：
>
> 1. **硬件简单性**：这个指令系统是否易于用简单的硬件来实现？
> 2. **应用清晰度**：用它来描述和解决实际问题时，逻辑是否清晰？
> 3. **处理速度**：用它来解决这些问题时，速度是否够快？
>
> 即使到了今天，“硬件简单性”这个考量因素，和在20世纪50年代时一样至关重要。

基于以上背景，本章的目标就是详细阐述这个贯穿始终的设计思想。具体来说：

1. **指令系统如何在硬件中表示**：揭示计算机底层的“0和1”是如何代表具体指令的。

2. **指令系统与高级语言的关系**：解释我们编写的C语言或Java这样的高级语言代码，最终是如何一步步翻译成计算机能懂的指令的。我们会用C语言作为示例，并会展示面向对象的语言（如Java）会带来怎样的变化。

**指令系统预览**：

1. **RISC-V的操作数 (Operands) - 计算机处理的对象**

在学习任何语言时，我们首先要知道它能操作哪些“东西”。在RISC-V中，这些“东西”就是操作数。主要分为两类：**寄存器和存储器**。

|名字|示例|注解|
| ---- | ---- | ---- |
|32个寄存器|`x0～x31`|CPU内部的“高速暂存区”或“草稿纸”。它们离计算核心非常近，访问速度极快。在RISC-V中，只对在寄存器中的数据执行算术运算|
|2⁶¹个存储字|`Memory[0], Memory[8], …, Memory[18446744073709551608]`|只能被数据传输指令访问。RISC-V使用字节寻址，因此顺序双字访问相差8。存储器保存数据结构、数组和换出的寄存器的内容|

>[!error] 核心规则
>
> 1. 在RISC-V中，**所有算术运算（加、减、乘、除等）都只能在寄存器中进行**。也就是说，想计算两个数，必须先把它们从别处（主要是存储器）拿到寄存器里，计算出结果后，结果也存放在寄存器里。
> 2. 存储器只能通过特定的数据传输指令（后面会讲）来访问。你不能直接对存储器里的数据做加法。

#### 2-1 计算机硬件的操作

