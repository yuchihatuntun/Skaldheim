##### T1：简述堆栈(stack)的基本概念及基本操作

堆栈是内存中的一块特殊区域，采用“先进后出（LIFO）”原则。在x86架构中，**栈底被固定在高地址**，**栈顶在低地址**，数据入栈时地址依次递减。`SP`（栈顶指针）动态指向最新入栈数据。

每次`PUSH`指令操作，数据压入更低地址，`SP`随之减小；`POP`则相反，栈顶数据被移到指定寄存器，`SP`随之增大。

##### T2：利用逻辑左移`SHL`和带进位循环左移`RCL`实现双字的逻辑左移；利用算术右移`SAR`和带进位循环右移`RCR`实现双字的算术右移；写汇编代码

已知双字（`DWord`）= ​32`bit`

###### 逻辑/算术左移

1. **对于八位机器（如 8080/8085）**：
	- `SHL` 用于最低位字节，在最低位补 `0`。
	- `RCL` 用于**后续所有**字节。把`CF`中的值放入前一节的最低位。

```asm
.DATA
    DWord DB 78H, 56H, 34H, 12H
.CODE
main PROC
    SHL BYTE PTR [DWord+0], 1   
    RCL BYTE PTR [DWord+1], 1
    RCL BYTE PTR [DWord+2], 1
    RCL BYTE PTR [DWord+3], 1
main ENDP
END main
```

2. **对于16位机器（如8086）**：我们将 `DX` (高16位) 和 `AX` (低16位) 组成的32位数（`DX:AX`）逻辑左移。
	
	- 我们先移**低位** (`AX`)，`SHL` 将`AX`的最高位 (bit 15) 挤出，并**存入 `CF` 标志位**。
	
	- 然后再移**高位** (`DX`)，利用`RCL` 将`DX`左移，并把`CF` 标志位中的（来自`AX`的）“进位“填充到`DX`的最低位 (bit 0)。

```asm
.DATA
    DWord_Low   DW 0C000H  ; 低16位
    DWord_High  DW 0A001H  ; 高16位
.CODE
main PROC
	  MOV AX, DWord_Low    ; AX = C000H
	  MOV DX, DWord_High   ; DX = A001H
	  SHL AX, 1            
	  RCL DX, 1            
main ENDP
END main
```

3. **对于32位机器（如80386）**：我们将 `EAX` 中的32位数逻辑左移。

```asm
.DATA
    DWord   DW 12345678H
.CODE
main PROC
	  MOV EAX, DWord
	  SHL EAX, 1                      
main ENDP
END main
```

###### 算术右移

1. **对于八位机器（如 8080/8085）**：
```asm
.DATA
    DWord DB 78H, 56H, 34H, 12H
.CODE
main PROC
    SAR BYTE PTR [DWord+3], 1
    RCR BYTE PTR [DWord+2], 1
    RCR BYTE PTR [DWord+1], 1
    RCR BYTE PTR [DWord], 1
main ENDP
END main
```

2. **对于16位机器（如8086）**：
```asm
.DATA
    DWord_Low  DW 0C000H  ; 低16位
    DWord_High DW 0A001H  ; 高16位

.CODE
main PROC
	MOV AX, DWord_Low    ; AX = C000H
	MOV DX, DWord_High   ; DX = A001H
    SAR DX, 1
    RCR AX, 1
main ENDP
END main
```
2. **对于32位机器（如80386）**：我们将 `EAX` 中的32位数算术右移。
```asm
.DATA
    DWord   DW 12345678H
.CODE
main PROC
	  MOV EAX, DWord
	  SAR EAX, 1                      
main ENDP
END main
```

##### T3：写出将源串（起始地址`SOURCE`）复制到目的串（起始地址`DEST`）的汇编程序，串长为100

```asm
STD                 ; 设置方向
LEA  SI, SOURCE     
LEA  DI, DEST       
MOV  CX, 100        ; 设置循环数为100
REP  MOVSB          
```
##### T4：简述`call`和`ret`的指令执行过程

###### **`CALL` 指令执行过程：**

1. **保存返回地址**:
    
    - **近调用**：将 `CALL` 指令**下一条**指令的偏移地址 (`IP`/`EIP`) **压入堆栈**。`SP`/`ESP` 相应减小 (2或4字节)。
        
    - **远调用**：先将当前的 `CS` **压入堆栈**，再将 `CALL` 指令**下一条**指令的偏移地址 (`IP`/`EIP`) **压入堆栈**。`SP`/`ESP` 相应减小 (4或8字节)。
        
2. **跳转**: 修改 `IP`/`EIP`（以及可能的 `CS`）指向被调用子程序的起始地址。
    

###### **`RET` (或 `RETF`) 指令执行过程：**

1. **恢复返回地址**:
    
    - **近返回 (`RET`)**: 从堆栈顶部**弹出**值，加载回 `IP`/`EIP`。`SP`/`ESP` 相应增加 (2或4字节)。
        
    - **远返回 (`RETF`)**: 先从堆栈顶部**弹出**值，加载回 `IP`/`EIP`，再**弹出**一个值，加载回 `CS`。`SP`/`ESP` 相应增加 (4或8字节)。
        
2. **继续执行**: CPU 从新的 `CS:IP`/`EIP` 地址开始执行指令（即回到了 `CALL` 指令之后的位置）。