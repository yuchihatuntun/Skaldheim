### 第二次作业

##### T1：简述堆栈(stack)的基本概念及基本操作

堆栈是内存中的一块特殊区域，采用“先进后出（LIFO）”原则。在x86架构中，**栈底被固定在高地址**，**栈顶在低地址**，数据入栈时地址依次递减。`SP`（栈顶指针）动态指向最新入栈数据。

每次`PUSH`指令操作，数据压入更低地址，`SP`随之减小；`POP`则相反，栈顶数据被移到指定寄存器，`SP`随之增大。

##### T2：利用逻辑左移`SHL`和带进位循环左移`RCL`实现双字的逻辑左移；利用算术右移`SAR`和带进位循环右移`RCR`实现双字的算术右移；写汇编代码

已知双字（`DWord`）= ​32`bit`

###### 逻辑/算术左移

1. **对于八位机器（如 8080/8085）**：
	- `SHL` 用于最低位字节，在最低位补 `0`。
	- `RCL` 用于**后续所有**字节。把`CF`中的值放入前一节的最低位。

```asm
.DATA
    DWord DB 78H, 56H, 34H, 12H
.CODE
main PROC
    SHL BYTE PTR [DWord+0], 1   
    RCL BYTE PTR [DWord+1], 1
    RCL BYTE PTR [DWord+2], 1
    RCL BYTE PTR [DWord+3], 1
main ENDP
END main
```

2. **对于16位机器（如8086）**：我们将 `DX` (高16位) 和 `AX` (低16位) 组成的32位数（`DX:AX`）逻辑左移。
	
	- 我们先移**低位** (`AX`)，`SHL` 将`AX`的最高位 (bit 15) 挤出，并**存入 `CF` 标志位**。
	
	- 然后再移**高位** (`DX`)，利用`RCL` 将`DX`左移，并把`CF` 标志位中的（来自`AX`的）“进位“填充到`DX`的最低位 (bit 0)。

```asm
.DATA
    DWord_Low   DW 0C000H  ; 低16位
    DWord_High  DW 0A001H  ; 高16位
.CODE
main PROC
	  MOV AX, DWord_Low    ; AX = C000H
	  MOV DX, DWord_High   ; DX = A001H
	  SHL AX, 1            
	  RCL DX, 1            
main ENDP
END main
```

3. **对于32位机器（如80386）**：我们将 `EAX` 中的32位数逻辑左移。

```asm
.DATA
    DWord   DW 12345678H
.CODE
main PROC
	  MOV EAX, DWord
	  SHL EAX, 1                      
main ENDP
END main
```

###### 算术右移

1. **对于八位机器（如 8080/8085）**：
```asm
.DATA
    DWord DB 78H, 56H, 34H, 12H
.CODE
main PROC
    SAR BYTE PTR [DWord+3], 1
    RCR BYTE PTR [DWord+2], 1
    RCR BYTE PTR [DWord+1], 1
    RCR BYTE PTR [DWord], 1
main ENDP
END main
```

2. **对于16位机器（如8086）**：
```asm
.DATA
    DWord_Low  DW 0C000H  ; 低16位
    DWord_High DW 0A001H  ; 高16位

.CODE
main PROC
	MOV AX, DWord_Low    ; AX = C000H
	MOV DX, DWord_High   ; DX = A001H
    SAR DX, 1
    RCR AX, 1
main ENDP
END main
```
2. **对于32位机器（如80386）**：我们将 `EAX` 中的32位数算术右移。
```asm
.DATA
    DWord   DW 12345678H
.CODE
main PROC
	  MOV EAX, DWord
	  SAR EAX, 1                      
main ENDP
END main
```

##### T3：写出将源串（起始地址`SOURCE`）复制到目的串（起始地址`DEST`）的汇编程序，串长为100

```asm
STD                 ; 设置方向
LEA  SI, SOURCE     
LEA  DI, DEST       
MOV  CX, 100        ; 设置循环数为100
REP  MOVSB          
```
##### T4：简述`call`和`ret`的指令执行过程

###### **`CALL` 指令执行过程：**

1. **保存返回地址**:
    
    - **近调用**：将 `CALL` 指令**下一条**指令的偏移地址 (`IP`/`EIP`) **压入堆栈**。`SP`/`ESP` 相应减小 (2或4字节)。
        
    - **远调用**：先将当前的 `CS` **压入堆栈**，再将 `CALL` 指令**下一条**指令的偏移地址 (`IP`/`EIP`) **压入堆栈**。`SP`/`ESP` 相应减小 (4或8字节)。
        
2. **跳转**: 修改 `IP`/`EIP`（以及可能的 `CS`）指向被调用子程序的起始地址。
    

###### **`RET` (或 `RETF`) 指令执行过程：**

1. **恢复返回地址**:
    
    - **近返回 (`RET`)**: 从堆栈顶部**弹出**值，加载回 `IP`/`EIP`。`SP`/`ESP` 相应增加 (2或4字节)。
        
    - **远返回 (`RETF`)**: 先从堆栈顶部**弹出**值，加载回 `IP`/`EIP`，再**弹出**一个值，加载回 `CS`。`SP`/`ESP` 相应增加 (4或8字节)。
        
2. **继续执行**: CPU 从新的 `CS:IP`/`EIP` 地址开始执行指令（即回到了 `CALL` 指令之后的位置）。.

### 第三次作业

#### T1：8086/8088 数据信号与地址信号是共用引脚的，怎样把这两种不同的信号分离出来？

8086/8088处理器采用了分时复用技术：

通过CPU的`ALE` (Address Latch Enable) 信号，配合外部的地址锁存器 (Address Latch) 来实现分离。

地址总线的**低位部分**和**数据总线**共用同一组物理引脚。

- **8088**：`AD0` - `AD7` (共8个引脚)，分时传送 `A0-A7` 和 `D0-D7`。

- **8086**：`AD0` - `AD15` (共16个引脚)，分时传送 `A0-A15` 和 `D0-D15`。

- 同时，地址总线的**高4位** (`A16-A19`) 也与**状态信号** (`S3-S6`) 分时复用。

**`ALE` 的功能**：当CPU将**有效的地址信息**放到复用总线（`AD`引脚）上时，`ALE` 引脚会发出一个**高电平脉冲**。

### 3. 核心硬件：地址锁存器 (Address Latch)

要实现分离，仅有CPU的`ALE`信号是不够的，系统必须在CPU外部配置相应的硬件。

- **所需器件**：**地址锁存器**。最常用的芯片型号是 **`74LS373`**（8位D型透明锁存器）或 `8282`（功能相同的Intel配套芯片）。
    
- **所需数量**：
    
    - 对于 **8088**：需要**2个** `74LS373`。一个用于锁存 `AD0-AD7` 上的 `A0-A7`，另一个用于锁存 `A16-A19`（高4位地址）。（`A8-A15` 在8088上是独立的，无需锁存）。
        
    - 对于 **8086**：需要**3个** `74LS373`。两个用于锁存 `AD0-AD15` 上的 `A0-A15`，另一个用于锁存 `A16-A19`。
        

### 4. 详细的分离工作流程（总线周期）

我们以一个内存读操作为例，来说明CPU、`ALE`、锁存器是如何协同工作的：

1. **T1 状态（时钟周期的开始）**：
    
    - CPU开始一个总线周期。
        
    - CPU将**完整的20位地址** (`A0-A19`) 放到地址/数据复用引脚上（例如 `AD0-AD15` 和 `A16-A19/S3-S6`）。
        
    - **同时**，CPU在 `ALE` 引脚上发出一个**高电平脉冲**。
        
2. **`ALE` 信号的下降沿**：
    
    - `74LS373` 锁存器的“锁存使能”(`LE` 或 `G`)引脚连接到CPU的 `ALE` 引脚。
        
    - 当 `ALE` 信号**由高变低（下降沿）**时，`74LS373` 被触发，它会**立刻“捕获”并“锁住”**其输入端（`D`端）上当前的信号状态（即 `A0-A19` 的地址信息）。
        
    - `74LS373` 的**输出端**（`Q`端）从此开始**持续、稳定地输出**被锁住的 `A0-A19` 地址信息。
        
3. **T2 状态（ALE变低后）**：
    
    - CPU **撤销** `AD` 引脚上的地址信号。`AD` 引脚现在**进入高阻态**，准备接收或发送数据。
        
    - **关键点**：此时，虽然 `AD` 引脚上的地址消失了，但 `74LS373` 锁存器的输出端（`Q`端）仍然**牢牢地保持**着 `A0-A19` 地址。
        
4. **T3 和 T4 状态（数据传送）**：
    
    - `AD` 引脚现在被用作**数据总线**。
        
    - **如果是读操作**：内存芯片（已接收到来自锁存器的稳定地址）将数据放到 `AD` 总线上，CPU读取数据。
        
    - **如果是写操作**：CPU将数据放到 `AD` 总线上，内存芯片（已接收到稳定地址）写入数据。
        
    - 在这个阶段，`ALE` 信号保持低电平，锁存器处于“锁存”状态，**完全无视** `AD` 总线上正在传送的数据，其输出端（`Q`端）的地址信号**不受任何干扰**。
        

### 总结

8086/8088通过**`ALE`信号**作为时间基准，在**时间上**将地址和数据错开；并通过**外部地址锁存器**（如 `74LS373`）作为**空间**上的分离器件。

- **`ALE` 脉冲有效期间**：`AD` 总线 = **地址总线**。
    
- **`ALE` 脉冲消失之后**：`AD` 总线 = **数据总线**。
    

通过这种方式，`AD` 引脚上的信号在 `ALE` 的控制下被“解复用” (Demultiplexed) 为两组独立的总线：

1. 一组来自**锁存器输出**的、**持续稳定**的**地址总线 (A0-A19)**。
    
2. 一组**分时复用**的、用于**数据交换**的**数据总线 (D0-D7 或 D0-D15)**。



