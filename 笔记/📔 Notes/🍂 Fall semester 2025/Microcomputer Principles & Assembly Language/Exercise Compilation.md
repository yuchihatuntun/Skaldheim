### 第二次作业

##### T1：简述堆栈(stack)的基本概念及基本操作

堆栈是内存中的一块特殊区域，采用“先进后出（LIFO）”原则。在x86架构中，**栈底被固定在高地址**，**栈顶在低地址**，数据入栈时地址依次递减。`SP`（栈顶指针）动态指向最新入栈数据。

每次`PUSH`指令操作，数据压入更低地址，`SP`随之减小；`POP`则相反，栈顶数据被移到指定寄存器，`SP`随之增大。

##### T2：利用逻辑左移`SHL`和带进位循环左移`RCL`实现双字的逻辑左移；利用算术右移`SAR`和带进位循环右移`RCR`实现双字的算术右移；写汇编代码

已知双字（`DWord`）= ​32`bit`

###### 逻辑/算术左移

1. **对于八位机器（如 8080/8085）**：
	- `SHL` 用于最低位字节，在最低位补 `0`。
	- `RCL` 用于**后续所有**字节。把`CF`中的值放入前一节的最低位。

```asm
.DATA
    DWord DB 78H, 56H, 34H, 12H
.CODE
main PROC
    SHL BYTE PTR [DWord+0], 1   
    RCL BYTE PTR [DWord+1], 1
    RCL BYTE PTR [DWord+2], 1
    RCL BYTE PTR [DWord+3], 1
main ENDP
END main
```

2. **对于16位机器（如8086）**：我们将 `DX` (高16位) 和 `AX` (低16位) 组成的32位数（`DX:AX`）逻辑左移。
	
	- 我们先移**低位** (`AX`)，`SHL` 将`AX`的最高位 (bit 15) 挤出，并**存入 `CF` 标志位**。
	
	- 然后再移**高位** (`DX`)，利用`RCL` 将`DX`左移，并把`CF` 标志位中的（来自`AX`的）“进位“填充到`DX`的最低位 (bit 0)。

```asm
.DATA
    DWord_Low   DW 0C000H  ; 低16位
    DWord_High  DW 0A001H  ; 高16位
.CODE
main PROC
	  MOV AX, DWord_Low    ; AX = C000H
	  MOV DX, DWord_High   ; DX = A001H
	  SHL AX, 1            
	  RCL DX, 1            
main ENDP
END main
```

3. **对于32位机器（如80386）**：我们将 `EAX` 中的32位数逻辑左移。

```asm
.DATA
    DWord   DW 12345678H
.CODE
main PROC
	  MOV EAX, DWord
	  SHL EAX, 1                      
main ENDP
END main
```

###### 算术右移

1. **对于八位机器（如 8080/8085）**：
```asm
.DATA
    DWord DB 78H, 56H, 34H, 12H
.CODE
main PROC
    SAR BYTE PTR [DWord+3], 1
    RCR BYTE PTR [DWord+2], 1
    RCR BYTE PTR [DWord+1], 1
    RCR BYTE PTR [DWord], 1
main ENDP
END main
```

2. **对于16位机器（如8086）**：
```asm
.DATA
    DWord_Low  DW 0C000H  ; 低16位
    DWord_High DW 0A001H  ; 高16位

.CODE
main PROC
	MOV AX, DWord_Low    ; AX = C000H
	MOV DX, DWord_High   ; DX = A001H
    SAR DX, 1
    RCR AX, 1
main ENDP
END main
```
2. **对于32位机器（如80386）**：我们将 `EAX` 中的32位数算术右移。
```asm
.DATA
    DWord   DW 12345678H
.CODE
main PROC
	  MOV EAX, DWord
	  SAR EAX, 1                      
main ENDP
END main
```

##### T3：写出将源串（起始地址`SOURCE`）复制到目的串（起始地址`DEST`）的汇编程序，串长为100

```asm
STD                 ; 设置方向
LEA  SI, SOURCE     
LEA  DI, DEST       
MOV  CX, 100        ; 设置循环数为100
REP  MOVSB          
```
##### T4：简述`call`和`ret`的指令执行过程

###### **`CALL` 指令执行过程：**

1. **保存返回地址**:
    
    - **近调用**：将 `CALL` 指令**下一条**指令的偏移地址 (`IP`/`EIP`) **压入堆栈**。`SP`/`ESP` 相应减小 (2或4字节)。
        
    - **远调用**：先将当前的 `CS` **压入堆栈**，再将 `CALL` 指令**下一条**指令的偏移地址 (`IP`/`EIP`) **压入堆栈**。`SP`/`ESP` 相应减小 (4或8字节)。
        
2. **跳转**: 修改 `IP`/`EIP`（以及可能的 `CS`）指向被调用子程序的起始地址。
    

###### **`RET` (或 `RETF`) 指令执行过程：**

1. **恢复返回地址**:
    
    - **近返回 (`RET`)**: 从堆栈顶部**弹出**值，加载回 `IP`/`EIP`。`SP`/`ESP` 相应增加 (2或4字节)。
        
    - **远返回 (`RETF`)**: 先从堆栈顶部**弹出**值，加载回 `IP`/`EIP`，再**弹出**一个值，加载回 `CS`。`SP`/`ESP` 相应增加 (4或8字节)。
        
2. **继续执行**: CPU 从新的 `CS:IP`/`EIP` 地址开始执行指令（即回到了 `CALL` 指令之后的位置）。.

### 第三次作业

#### T1：8086/8088 数据信号与地址信号是共用引脚的，怎样把这两种不同的信号分离出来？

8086/8088处理器通过分时复用技术来共享引脚。信号的分离是依靠CPU的`ALE` (Address Latch Enable) 控制信号和外部的**地址锁存器 (Address Latch)** 硬件（如`74LS373`或`8282`）协同实现的。

其工作流程遵循严格的时序：

1. T1状态（地址周期）: CPU在总线周期的T1状态，将完整的地址信息（`A0-A19`）输出到复用总线（`AD0-AD15`及`A16-A19/S3-S6`）上。

2. CPU在`ALE`引脚上发出一个高电平脉冲。此信号的下降沿被用作外部地址锁存器的锁存使能 (`LE`)信号。

3. 锁存器在`ALE`下降沿捕获并保持（latch）复用总线上的地址信息。锁存器的输出端（`Q`端）即构成了一组解复用的、在整个总线周期内保持稳定的地址总线。

4. T2-T4状态（数据周期）: `ALE`信号变低后，CPU不再驱动复用总线上的地址。该总线引脚（`AD`）进入高阻态，并在T2-T4状态期间转而用作双向数据总线，进行数据传送。

#### T2：在存储器访问总线周期的T1、T2、T3、T4状态时,CPU分别执行什么动作? 什么情况下需要插入等待状态Tw? Tw在哪儿插入? 怎样插入?


1. T1 (地址/状态周期): CPU在T1状态**发起**总线周期。它将20位的物理地址（Address）输出到分时复用的地址/数据总线（`AD0-AD15`）和地址/状态总线（`A16-A19/S3-S6`）上。同时，CPU设定`ALE` (Address Latch Enable) 信号为高电平，以通知外部地址锁存器（如74LS373）捕获总线上的地址信息。

2. T2 (控制周期): CPU撤销 `ALE` 信号。地址信息此时已被外部锁存器稳定保持。CPU撤回其在复用总线上的地址输出，总线进入高阻态 (Hi-Z)，为数据传输做准备。

3. T3 (数据传输周期): 对于**读周期**: CPU在该时钟状态的末尾对数据总线进行采样 (Sample)，读取由存储器或I/O设备（在T2中已被`RD#`激活）放置的数据；对于**写周期**: CPU在T2之后、T3期间将有效数据放置到数据总线上。存储器或I/O设备利用`WR#`信号的有效（低）电平将数据写入。

4. T4 (总线周期结束): CPU撤销（驱动为高电平）在T2时断言的控制信号（`RD#`或`WR#`）。


当CPU的总线周期时序（从T1输出地址到T3采样数据的时间）快于存储器或I/O设备的访问时间 (Access Time) 时，就需要插入等待状态。

等待状态 $T_W$ 被插入到T3状态之后、T4状态之前。

等待状态的插入是通过CPU的 **`READY`** 输入引脚和外部硬件逻辑（如等待状态发生器）的同步 (Synchronization) 来实现的。

#### T3：在T1状态下,8088/8086CPU数据/地址线上是什么信息?用哪个信号可将此信息锁存起来?数据信息是什么时候送出的?在最大组态下,怎样使系统地址总线和系统数据总线上同时分别存在地址信息和数据信息?

在T1状态，分时复用总线（`AD`引脚及`A/S`引脚）上传送的是20位的物理地址信息。

**锁存信号**: `ALE` (Address Latch Enable) 信号。

**数据时间**: 数据信息在T2-T4状态期间于`AD`总线上进行传送（T3状态数据有效）。

**最大组态解复用**: 在最大组态（Max Mode）下，系统通过解复用硬件实现。

1. `8288`总线控制器在T1状态输出`ALE`信号，将CPU引脚上的地址锁存到外部地址锁存器（如`8282`）中。

2. 该锁存器的输出构成了在T1-T4全程持续有效的系统地址总线。

3. T2-T4状态，`8288`再以`DEN` 和`DT/R#`信号控制外部数据收发器（如`8286`）。

4. 该收发器的总线侧构成了独立的系统数据总线，用于数据交换。

因此，在T2-T4状态，地址信息（由锁存器保持）和数据信息（由收发器传输）在两条独立的系统总线上同时存在。
#### T4：RESET信号到来后,8086/8088系统的CS和IP分别等于多少?

在`RESET`信号有效后，8086/8088 CPU的内部状态被初始化：

- CS寄存器被硬件置为 **`FFFFH`**。
    
- IP寄存器被硬件置为 **`0000H`**。

#### T5：在中断响应过程中,8086/8088住8259A发的两个INTA信号分别起什么作用?

-  `INTA#` 信号 (Priority Resolution): 此信号通知8259A（可编程中断控制器）其`INTR`已被CPU接收。8259A利用此脉冲进行内部优先级仲裁，确定其所连接的多个中断源（IR0-IR7）中，优先级最高的、未被屏蔽的、正在请求中断的设备。它随后将该设备的对应位在ISR中置位。
    
-  `INTA#` 信号 (Vector Retrieval): 此信号通知8259A将中断向量号放置到数据总线（`AD0-AD7`）上。8259A在接收到此信号后，将其内部已配置的8位中断向量号（即中断类型码）输出到数据总线。CPU（在其T3状态）从数据总线采样此向量号，并用它来计算在中断向量表（IVT）中对应的服务例程（ISR）的入口地址。