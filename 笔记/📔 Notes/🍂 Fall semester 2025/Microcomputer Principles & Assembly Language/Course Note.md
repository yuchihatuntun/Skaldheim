### 课程目标与成绩要求

#### 课程目标

- <span style="background:rgba(163, 218, 252, 0.55)">微型计算机（Intel x86）的基本工作原理及系统</span>，Intel x86是广泛使用的计算机架构，了解其基本工作原理有助于理解计算机如何执行指令、处理数据等核心运作机制。
- <span style="background:rgba(163, 218, 252, 0.55)">处理器体系结构</span>，处理器是计算机的核心部件，学习其体系结构能知晓处理器的内部构造、指令集等，明白它如何高效地进行计算和控制。
- <span style="background:rgba(163, 218, 252, 0.55)">软件及汇编语言程序设计</span>，汇编语言是一种接近机器语言的编程语言，学习它有助于深入理解计算机软件与硬件的交互，能让学习者从底层层面去设计和编写程序，为后续的软件开发等工作奠定基础。

#### 课程资料与成绩组成

|材料类别|具体内容|
| ---- | ---- |
|主要教学内容|上课ppt，上传到中山大学在线教学平台<https://lms.sysu.edu.cn/my/index.php>|
|教材|《微机原理、汇编语言与接口技术》，周杰英、张萍、郭雪梅、黄方军编著，人民邮电出版社|
|辅助材料| - 《计算机组成与设计：硬件/软件接口（原书第5版·ARM版）》，戴维·A.帕特森（David A.Patterson）、约翰·L.亨尼斯著，陈微译，机械工业出版社出版，第1版，2018年9月<br> - Randal E. Bryant and David R. O'Hallaron, *Computer Systems: A Programmer’s Perspective*, Third Edition (CS:APP3e), Pearson, 2016.|

|成绩类型|占比|具体说明|
| ---- | ---- | ---- |
|平时成绩|40%|包括作业和考勤|
|期末成绩|60%|考试方式为闭卷，成绩评定采用百分制|

### 绪论outline

> [!note]
> **什么是嵌入式系统，和其他系统有什么区别**
>
> 嵌入式系统是**以应用为中心、以计算机技术为基础**，软硬件可裁剪（根据需求定制），能满足设备对功能、可靠性、成本、体积、功耗严格要求的**专用计算机系统**。它并非独立设备，而是“嵌入”到其他设备（如家电、汽车、工业机械）中的核心控制单元，本质是为特定场景提供精准控制或数据处理能力。
>
> **嵌入式系统的核心构成**
>
> - **硬件层**：以微处理器（MPU）、微控制器（MCU，如STM32、51单片机）、片上系统（SoC）为核心，搭配专用外设（如传感器、执行器、通信模块）和最小化电路（电源、时钟、存储），资源高度精简（通常内存几KB~几GB、存储几MB~几百GB）。
> - **软件层**：以“专用固件”为核心，通常包含实时操作系统（RTOS，如FreeRTOS、uC/OS）或无操作系统（裸机程序），软件功能单一且固化（多存储在ROM/Flash中，而非可随意安装卸载），专注于完成特定任务（如“控制电机转速”“采集温度数据”）。
> - **典型应用场景**：汽车电子（发动机ECU、中控屏）、智能家居（冰箱温控、扫地机器人）、工业控制（PLC控制器、传感器节点）、消费电子（智能手环、路由器）、医疗设备（血糖仪、心电监测仪）等。
>
> **嵌入式系统与其他系统的核心区别**
>
> 嵌入式系统的核心特征是“**专用化**”，而通用计算机、服务器等系统的核心特征是“**通用化**”。以下通过对比表格，清晰区分嵌入式系统与两类常见系统的差异：
>
> | 对比维度                | 嵌入式系统                                  | 通用计算机系统（PC/笔记本）                | 服务器系统（数据中心服务器）                |
> |-------------------------|---------------------------------------------|-------------------------------------------|---------------------------------------------|
> | **设计目标**            | 满足特定设备的单一/少数功能（如“控制汽车刹车”“监测心率”），强调**实时性、可靠性、低功耗** | 满足多场景通用需求（办公、娱乐、编程），强调**灵活性、多任务处理** | 满足大规模数据处理/服务提供（云计算、数据库），强调**高吞吐量、高并发、稳定性** |
> | **软硬件架构**          | 软硬件高度定制化，硬件资源精简（按需裁剪），软件多为“裸机程序/轻量RTOS”，功能固化 | 硬件标准化（CPU、内存、硬盘可灵活升级），软件通用化（支持Windows、Linux，可随意安装卸载应用） | 硬件高性能（多CPU、大内存、冗余存储），软件专用化（如Linux Server、数据库系统），支持集群扩展 |
> | **性能与资源**          | 性能适中（CPU主频几MHz~几GHz），资源有限（内存几KB~几GB、存储几MB~几百GB） | 性能均衡（CPU主频2~5GHz），资源丰富（内存8~64GB、存储512GB~数TB） | 性能极致（多路CPU、内存128GB~数TB、存储PB级），支持硬件冗余（如双电源、RAID） |
> | **用户交互**            | 多为“无交互”或“极简交互”（如家电通过按键/APP间接控制，工业设备通过专用面板操作） | 强交互（依赖显示器、键盘、鼠标，支持图形化界面） | 无直接用户交互（通过网络远程管理，面向程序/服务调用） |
> | **生命周期**            | 长（5~20年，如汽车电子、工业设备需长期稳定运行，不轻易升级） | 短（3~5年，硬件易迭代，软件需频繁更新） | 中长（5~10年，硬件按需升级，软件需持续维护以保障服务） |
> | **实时性要求**          | 多数有严格实时性（如汽车ECU需毫秒级响应刹车信号，工业控制需微秒级同步） | 无强制实时性（如办公软件延迟1~2秒可接受） | 侧重“吞吐量”而非“实时性”（如云计算服务延迟100ms内可接受） |

#### 计算机系统：硬件+软件

![alt text](image-4.png)

#### 计算机和处理器的推动力及历史

> [!note] “后摩尔时代”
>
> **“后摩尔时代”**指的是传统依靠“缩小晶体管尺寸”提升芯片性能和集成度的路径逐渐逼近物理极限，芯片技术发展从“单一维度迭代”转向“多维度创新”的新阶段，并非摩尔定律完全失效。
>
> 1. 进入“后摩尔时代”的原因
>
> - **物理极限**：晶体管尺寸缩小到5nm以下时，出现量子隧穿效应，导致漏电和性能不稳定，导线宽度也逼近原子尺度，难以继续缩小。
> - **成本飙升**：先进工艺生产线和研发成本极高，仅少数巨头能承担，性价比降低。
> - **功耗与散热问题**：晶体管密度提升导致热密度急剧上升，散热困难，影响芯片可靠性。
>
> 2. 后摩尔时代的核心特征
>
> - **不再依赖尺寸缩小**：通过3D立体结构（如3D晶体管、纳米片晶体管）提升密度。
> - **不再依赖单一芯片**：采用多芯片集成（如SoC堆叠、Chiplet技术）提升性能与灵活性。
> - **不再依赖传统硅基材料**：探索氮化镓、碳化硅等新材料，以及碳纳米管、石墨烯等前沿技术，突破物理瓶颈。

- **发展阶段**：
  - 1945 - 1970年，主要是大型计算机（Mainframes）和小型计算机（minicomputers）。
  - 70年代，集成电路技术催生了微型计算机（microcomputer）。
  - 80年代，精简指令集（RISC）处理器开始出现。
  - 2005年以后，多核处理器逐渐发展起来。
- **处理器设计关键技术**：涵盖流水线、指令并行（超标量、VLIW）、数据并行（SIMD）、多核、缓存等，推动了处理器性能提升。

| 技术类型      | 定义与实现方式                                              | 代表架构/产品                | 主要优缺点                  | 适用场景                  |
|---------------|------------------------------------------------------------|-----------------------------|-----------------------------|---------------------------|
| 超标量        | 硬件动态调度，多条指令并行执行（如乱序执行）                | Intel Pentium、ARM Cortex-A | 兼容性强，性能高，硬件复杂  | 通用计算、高性能CPU        |
| VLIW          | 编译器静态打包多指令，处理器并行执行                        | TI TMS320C62XX、Itanium     | 硬件简单，需重编译，代码膨胀| DSP、多媒体、嵌入式        |
| SIMD          | 一条指令并行处理多个数据（如向量、数组）                    | Intel SSE/AVX、ARM NEON     | 吞吐高，需数据对齐          | 多媒体、科学计算、信号处理 |

| 处理器名 | 时间 | 晶体管数 | 速度（MHz） | 关键特点 |
| ---- | ---- | ---- | ---- | ---- |
| 8086 | 1978 | 29K | 5 - 10 | 首款16位英特尔处理器，是IBM PC和DOS的基础，地址空间为1MB |
| 80386 | 1985 | 275K | 16 - 33 | 首款32位英特尔处理器，被称为IA32，增加了“平面寻址”，能运行Unix |
| Pentium 4E | 2004 | 125M | 2800 - 3800 | 首款64位英特尔x86处理器，被称为x86 - 64 |
| Core 2 | 2006 | 291M | 1060 - 3500 | 首款英特尔多核处理器 |
| Core i7 | 2008 | 731M | 1700 - 3900 | 拥有四个核心 |

#### 解决微处理器挑战的可能方向

- **领域专用处理器**：一方面有面向AI应用的GPU及加速器，可助力人工智能相关任务高效运行；另一方面随着技术发展，也会催生其他新应用场景下的专用处理器。
- **新型体系架构关键技术的突破**：包括存算一体的器件、电路及架构，这种架构能优化计算与存储的协同；还有类脑芯片，模仿人脑的工作机制，有望带来全新的计算模式。
- **新型存储器关键技术的突破**：聚焦于高速、高容量的非易失存储器，像RRAM（电阻式随机存取存储器）、MRAM（磁随机存取存储器）、PRAM（相变随机存取存储器）等，这类存储器在性能和存储能力上有更好表现。

### 第二章 微处理器结构

冯·诺依曼计算机结构

我们今天使用的几乎所有电脑、手机、服务器，其最核心的设计思想都源于此。

![alt text](image-17.png)

1. **输入设备 (Input Devices)**

从外部获取信息的设备。在电脑上，键盘、鼠标、麦克风就是输入设备，负责把你的指令和数据告诉计算机。

2. **存储器 (Memory/Storage)**

存放数据和指令的地方。在电脑里，内存（RAM）和硬盘（Hard Drive）就是存储器，程序和需要处理的文件都放在里面。

3. **微处理器 (Microprocessor / CPU)**：计算机的大脑，它由两个关键部分组成：

- **运算器 (Arithmetic Logic Unit, ALU)**
    执行算术和逻辑运算。所有实际的数据处理都在这里完成。

- **控制器 (Control Unit, CU)**
    指挥和协调计算机各部分工作。计算机中所有部件的行动，都是由控制器来发号施令的。

4. **输出设备 (Output Devices)**

将处理结果展示给用户。在电脑上，显示器、打印机、音响就是输出设备，它们把计算机处理完的结果（文字、图像、声音）展示给你。

**采用二进制**：计算机内部的所有信息，无论是指令还是数据，最终都会被转换成由0和1组成的二进制码。简单、稳定，适合用电子元器件来实现。

**“存储程序”思想 (Stored-Program Concept)**：在冯·诺依曼之前，计算机的程序是固化在硬件里的（通过插拔无数根电线来改变程序，就像**ENIAC**）。而冯·诺依曼提出，程序（指令）本身也应该像数据一样，被存储在存储器中。计算机可以按顺序自动地从存储器中取出指令并执行。这个思想的伟大之处在于，它实现了<span style="background:rgba(163, 218, 252, 0.55)">软件和硬件的分离</span>。我们想让计算机做不同的事，不再需要改造硬件，只需要加载不同的软件（程序）就行了。

```c
int global_data = 10;        // 存储在数据段 (DS)
int source_array[10] = {1};  // 存储在数据段 (DS)
int dest_array[10];          // 存储在数据段 (DS)

// 一个简单的函数，用于演示堆栈操作
int add_func(int a, int b) 
{
    int sum;         // 局部变量, 存在于堆栈 (SS:BP)
    sum = a + b;     // 触发 ALU 和 标志
    return sum;      // 使用 AX 返回
}

void main() 
{
    // 1. 函数调用
    int local_result;
    local_result = add_func(5, 20); // 触发 CALL/RET, PUSH/POP
    
    // 2. 数组(字符串)复制
    for(int i=0; i<10; i++) { 
     dest_array[i] = source_array[i]; 
  }
    // 汇编中常使用 REP MOVSW 指令
    
    // 3. 全局变量操作
    global_data = global_data + local_result; // 访问 DS, 使用 ALU
}
```

### 第三章 80x86 指令系统

#### 80x86 寻址方式

##### 背景——存储器的体系结构

现实中不存在完美的单一存储器。因此，设计师们设计了一个 **“金字塔”** 式的 **分层体系结构 (Hierarchy)**，用系统，用“较低成本”的硬件“欺骗”CPU，让它以为自己拥有了近乎“理想”的存储器。

###### “存储金字塔”的层级（从上到下，从快到慢）

**第1层：CPU 寄存器 (CPU Registers)**

- **特点**：在CPU芯片内部，与CPU的计算单元“零距离”。访问速度**最快**（1个时钟周期），但数量极少（几十个），<span style="background:rgba(186, 173, 239, 0.55)">成本极高</span>。`AX`, `EBX` 这些就是寄存器。

**第2层：高速缓冲存储器 (Cache)**

- **特点**：焊在CPU芯片上或紧贴CPU的超高速小内存。它存在的唯一目的就是**缓解CPU（超快）和主存（很慢）之间的速度矛盾**。

**第3层：主存储器 (Main Memory / RAM)**

- **特点**：我们常说的“内存条”（如16GB RAM）。CPU执行的所有程序和数据，都必须**先从硬盘加载到这里**才能运行。<span style="background:rgba(186, 173, 239, 0.55)">它的速度远慢于Cache，但容量远大于Cache</span>。

**第4层：辅助存储器 (Auxiliary Storage)**

- **特点**：我们常说的“移动硬盘“。容量巨大、价格便宜、断电不丢失数据。但速度最慢。

###### 体系的运作：局部性原理 (Principle of Locality)

这个金字塔体系能高效工作的核心，是利用了程序的“惰性”，即**局部性原理**：

1. **时间局部性**：刚用过的数据，很可能马上还要再用一次。（比如循环变量 `i`）。

2. **空间局部性**：刚用过的数据，它旁边的数据，很可能马上也要被用。（比如数组`a[1]`用完，很可能就用`a[2]`）。

**工作流程**：

1. CPU需要数据，先问 **Cache** 有没有

2. **Cache命中 (Hit)**：若Cache里正好有。CPU立刻拿到数据，皆大欢喜。（电脑第二次打开同一个软件会快很多）。

3. **Cache未命中 (Miss)**：Cache里没有。CPU**被迫停工（Stall）**，等待Cache去问**主存**要。主存把数据（连同一小块邻近的数据）一起交给Cache，Cache再交给CPU。

##### 指令格式

一条指令，就是程序员能对CPU下达的、最基本的一个命令。

指令的两大组成部分：

- **操作码 (Opcode) / 助记符 (Mnemonic)**

  - **作用**：指令的 **“动词 (Verb)”** ，规定了CPU **“做什么”** 。

  - **例**：`MOV` (传送)、`ADD` (加法)、`SUB` (减法)、`JMP` (跳转)。

  - **助记符**：`MOV` 是给人看的“助记符”。但CPU真正看的是机器码，比如`B8`。

- **操作数 (Operands)**

  - **作用**：指令的 **“宾语 (Object)”** ，规定了CPU **“对谁做”**、**“用什么做”** 。

  - **例**：在`MOV AX, 1234H`中，`AX` 和 `1234H` 就是两个操作数。

  - **说明**：不同指令的操作数个数不同。`INC AX` (让`AX`自增1) 只有一个操作数；`MOV AX, 1234H` 有两个；`RET` (函数返回) 可以没有操作数。

> [!note] 以`MOV`指令作为典型案例：
>
> - **格式**：`MOV 目的操作数, 源操作数`
> - **功能**：将**“源”**的数据，**复制**一份，传送到**“目的”**。
> - **注**：这是x86架构的Intel语法，**目标在左，源在右**。这就像一个赋值语句：`目的 = 源`。
>
##### 寻址方式

- **立即寻址 (Immediate)**：操作数包含在代码中。

**数据就在“指令”上写着**。比如命令是：“拿`1234`这个数字”。数据`1234`本身就是命令的一部分。

- **寄存器寻址 (Register)**：操作数存放在寄存器中。

**数据就在CPU的“口袋”里**（`AX`, `EBX`等寄存器）。这是CPU最喜欢的方式，因为拿取速度**最快**，零延迟。

- **存储器寻址 (Memory)**：操作数存放在存储器中。

**数据在“外面的大仓库”里**（内存）。CPU需要拿着“地址”（仓库货架号）跑过去取，这会花费一些时间（涉及Cache, 主存）。

- **I/O端口寻址 (I/O Port)**：操作数存放在I/O端口中。

**数据在“公司大门口的快递站”**。数据来自外部设备（如键盘、网卡）。CPU需要执行特殊指令（如 `IN`, `OUT`）去签收。

> [!danger]
> 寻址方式是**针对操作数**而言的。
>
> - 在一条指令 `MOV AX, BX` 中：
>
>   - **目的操作数** `AX`，使用的是“寄存器寻址”。
>
>   - **源操作数** `BX`，使用的也是“寄存器寻址”。
>
> - 在一条指令 `MOV AX, [1234H]` 中：
>
>   - **目的操作数** `AX`，使用的是“寄存器寻址”。
>
>   - **源操作数** `[1234H]`，使用的是“存储器寻址”。
>
###### 立即寻址

**定义**：操作数（数据）就**紧跟在操作码后面**，作为指令机器码的一部分，存放在内存的**代码段**中。

>[!note] 案例分析（`MOV AX, 1234H`）
>**“完整指令”** 被分为两部分：
>
>1. **操作码 (Opcode)**：`MOV AX, ...` 的机器语言。CPU一读到这个码，就知道接下来是一个16位的数据，我要把它装进`AX`。
>
>2. **立即数 (Immediate Data)**：就是`1234H`。

> [!warning] 小端序 (Little-Endian) 存储
> 数据部分被拆成了 `34H(低8位)` 和 `12H(高8位)`。在内存中存放时，`34H`（低位字节）被存放在**较低的地址**，`12H`（高位字节）被存放在**较高的地址**。 Intel x86 架构的“小端序”规定，多字节数据的“小头”（低位字节）要存放在“小地址”（低地址）。

> [!note] 案例分析（`MOV AL, 12H`）
>
> 这是一个8位操作。操作码会告诉CPU："接下来是一个8位的数据，把它装进`AL`"。
> 内存中就是 `[Opcode] [12H]`。

> [!note] 案例分析（`MOV AX, 12H`）
>
> 源操作数 `12H` 是8位的，但目的寄存器 `AX` 是16位的。CPU在执行时，会自动进行 **"零扩展" (Zero Extension)** 。它会将 `12H` 装入 `AL` (低8位)，同时**自动用 `00H` 填充 `AH` (高8位)**。因此执行后 `AX` 的值是 `0012H`。

> [!note] 案例分析（MOV EAX, 12345678H）：从16位 (8086) 走向32位 (80386)
>
> 1. 它会有一个**操作码 (Opcode)**，告诉CPU："这是一条`MOV` 32位立即数到`EAX`的指令"。
>
> 2. 这4个字节的数据 `12345678H` 会以**小端序 (Little-Endian)** 的方式存放在内存中。
>
> 3. 在内存中的实际字节顺序是：`[Opcode] [78H] [56H] [34H] [12H]`。

> [!tip] 拓展（C3-1）：立即寻址的重要性
>
> 1. **编译器（Compiler）** 的最爱：当在 **C++** 或 **Java** 中写 `int i = 10;` 或者 `for (int j = 0; j < 100; j++)`，这里的 `10` 、 `0` 、 `100` 几乎100%会被编译器编译成使用**立即寻址**的指令（如 `MOV EAX, 10`）。
> 2. **立即数的性能**：数据随着指令**一起被取回来了**（大概率已在CPU的指令缓存`L1-Cache`中）。CPU不需要再跑一趟去访问数据缓存（`L1-Data-Cache`）或主存，避免了潜在的流水线停顿（`Stall`）。
> 3. **RISC-V** 中的立即数：在 **ARM** 和 **RISC-V** 中，由于RISC指令长度固定（如32位），它们没有空间放下超长的立即数。因此，它们会设计特殊的指令（如 `LUI` - Load Upper Immediate），专门用来分两步拼装一个大的立即数，或者将立即数的设计与指令格式巧妙地融合在一起，这是现代CPU设计的一个核心挑战。

###### 寄存器寻址

操作数就存放在寄存器中，所有的高级语言**编译器**（如C++, Java, Python的）其核心优化任务之一就是 **“寄存器分配”** 。编译器会拼尽全力分析你的代码，把最常用、最核心的变量（比如`for`循环中的变量`i`）尽可能地长时间 **“钉死”在寄存器里** ，这也是为什么优化后的代码会快得多。

> [!note] 案例分析
>
> - **例1: `MOV AX, BX`**
>
> 经典的16位传送。将`BX`寄存器中全部16位的内容，完整地复制到`AX`寄存器中。
>
> - **例2: `MOV EAX, EBX`**
>
> 这是80386时代的32位传送。原理完全相同，但数据"水管"的直径从16位变成了32位。
>
> - **例3: `MOV CL, CH`**
>
> CPU内部操作的**高精度**。`CH`是`CX`寄存器的高8位（`C` register `High` byte），`CL`是`CX`的低8位（`C` register `Low` byte）。这条指令是把高8位的数据，复制到低8位。这在进行字节（Byte）级别的复杂数据拼装时非常有用。

###### 存储器寻址

程序的大部分数据，如变量、数组、对象等，都存放在**内存**里。

**偏移地址的计算：16位机 (如8086)**

我们知道8086的物理地址是 `段地址:偏移地址`。“存储器寻址”要干的所有事情，就是**计算出这个“偏移地址”**。这个计算出来的“偏移地址”，在术语中就叫做**有效地址 (EA)**，即：

`偏移地址（16位）=有效地址（EA） = 基址 (Base) + 变址 (Index) + 位移量 (Displacement)`

- **基址 (Base)**：`BX` 或 `BP`
  - **`BX`** (Base Register) 通常用于指向**数据段 (`DS`)** 中的数据。
  - **`BP`** (Base Pointer) 专门用于指向**堆栈段 (`SS`)** 中的数据。

- **变址 (Index)**：`SI` 或 `DI`
  - **作用**：在“基础货架号”上提供一个“动态的偏移”。
  - **`SI`** (Source Index) / **`DI`** (Destination Index) 适合用来做“索引”，比如数组的遍历。

- **位移量 (Displacement)**：一个8位或16位的常数（如 `8` 或 `1234H`）。
  - **作用**：提供一个“固定的偏移”。

**偏移地址的计算：32位机 (如80386)**

`EA = 基址 + (变址 * 比例因子) + 位移量`

- **更灵活的基址/变址**：**任何**通用寄存器 (`EAX`, `EBX`, `ECX`...) 都可以充当“基址”或“变址”。这给了编译器极大的自由度。
- **更大的位移量**：可以使用32位的常数，轻松访问大型数据结构。
- **比例因子 (Scale Factor: 1, 2, 4, 8)**：这是**最重要的升级**。允许CPU在计算EA时，自动将“变址”寄存器的值乘以1、2、4或8。

> [!tip] 拓展（C3-2）: 为什么"比例因子"是革命性的？
>
> 这个功能是**为高级语言（如C/C++）量身定做的**。假设你在C++中定义了一个整数数组： `int my_array[10];`:
>
> 在32位系统中，一个 `int` 占**4个字节**。
>
> - `my_array[0]` 在内存地址 `Addr`
> - `my_array[1] A` 在内存地址 `Addr + 4`
> - `my_array[2]` 在内存地址 `Addr + 8`
>
> 现在，你想执行这行代码：`x = my_array[i];`，CPU必须计算出 `my_array[i]` 的地址，公式是：`Addr + i * 4`。
>
> **在8086上 (没有比例因子)**：CPU必须分多步执行，非常慢：
>
> ```asm
> MOV CX, i      ; 1. 把 i 放到一个寄存器
> SAL CX, 2      ; 2. 把 CX 乘以 4 (左移2位)
> MOV BX, Addr   ; 3. 把数组基地址放到 BX
> ADD BX, CX     ; 4. 计算出 EA
> MOV AX, [BX]   ; 5. 终于取到了数据！
> ```
>
> **在80386上 (有比例因子)**：硬件一步到位！
>
> ```asm
> MOV EAX, i                    ; 1. 把 i 放到 EAX (作为变址)
> MOV EBX, [Addr + EAX * 4]     ; 2. 搞定！
> ```
>
> 这个`比例因子`（1, 2, 4, 8）就是为了直接在硬件层面支持 `char` (1字节), `short` (2字节), `int/float` (4字节), `double/long long` (8字节) 这些**C语言基本数据类型的数组访问**。这是硬件辅助软件性能起飞的绝佳范例。

**“默认段规则”**：

1. 如果`EA`计算中**使用了 `BP`, `EBP` 或 `ESP`**，CPU就**自动**认为是在**堆栈段 (SS)** 里找数据。

2. 否则（比如用了`BX`, `EAX`, `SI`等），CPU就**自动**认为是在**数据段 (DS)** 里找数据。

**为什么有这个规则？—— 为了函数和局部变量**

- **数据段 (DS)** 用来存放**全局变量 (Global Variables)**。
- **堆栈段 (SS)** 用来存放**函数的参数 (Parameters)** 和**局部变量 (Local Variables)**。

当你调用一个C函数 `my_func(int a)` 时：

1. 参数 `a` 被压入堆栈。
2. 函数开始执行，`EBP` 寄存器会指向这块堆栈区域的“基底”（称为栈帧）。
3. 你的参数 `a` 就在 `[EBP + 8]` 的位置。
4. 你的局部变量 `int x` 就在 `[EBP - 4]` 的位置。

当编译器编译 `x = a;` 这句代码时，它会生成： `MOV EAX, [EBP+8] ; CPU自动使用SS段, 取回参数a` ，`MOV [EBP-4], EAX ; CPU自动使用SS段, 存入局部变量x`

这个规则让编译器可以清晰地将**全局数据（DS）** 和**函数内数据（SS）** 隔离开来。

>[!danger] 消失的段地址
>段地址几乎从来不会直接写在指令语句中。它就是根据计算有效地址(`EA`)的寄存器来自动“默认匹配”的。
>
>CPU内部有一套“默认规则表”，规定了在计算`EA`时使用了什么寄存器，就自动匹配哪个段寄存器
>
>**段超越 (Segment Override)**：
>
>汇编语言提供了一个“例外”机制，叫做**段超越前缀 (Segment Override Prefix)**。您可以在指令前面手动指定一个段寄存器，来**临时“覆盖”**掉默认规则。
>
>- 默认情况 (用DS)：`MOV AX, [BX]` $\implies$  物理地址 = `(DS) * 16 + (BX)`
>- 使用“段超越” (强制用ES)：`MOV AX, ES:[BX]` $\implies$  物理地址 = `(ES) * 16 + (BX)`

1. **直接寻址**：程序直接通过操作数的地址来访问该操作数。

在 `EA = 基址 + 变址 + 位移量` 这个公式中，让 **基址=0, 变址=0**。因此，`EA = 位移量`。这个“位移量”（偏移地址）是一个**常数**（如`1234H`），被**直接编码在指令的机器码中**。

> [!note] 案例：默认寻址 (`MOV AX, [1234H]`)
>
> ![alt text](image-26.png)
>
> - **第1步：计算16位有效地址 (EA)**
>
>   - 寻址方式是"直接寻址"。`EA = 0 + 0 + 1234H`
>
> - **第2步：计算20位物理地址**
>
>   - CPU检查指令，发现没有`BP`寄存器参与运算。按照**默认规则**，CPU自动选择**数据段寄存器 (DS，设 `(DS) = 5000H`)** 。
>   - `物理地址 = (DS) * 16 + EA = 5000H * 10H + 1234H = 51234H`

- CPU跑到`51234H`这个物理地址去取数据。
- **小端序(Little-Endian)再次登场**：

  - CPU在**低地址`51234H`** 读到了`89H`，将其放入`AX`的**低8位(AL)**。
  - CPU在**高地址`51235H`** 读到了`67H`，将其放入`AX`的**高8位(AH)**。

- **运行结果**：`AX`寄存器中最终的值是 `6789H`。

> [!tip] 拓展（C3-3）：直接寻址的工业应用
>
> "直接寻址"在现代编程中用于访问**全局变量 (Global Variables)** 和 **静态变量 (Static Variables)**。
>
> 当编译器（如C++编译器）编译程序时，它会把所有全局变量统一安放在数据段（.data段）的某个固定位置。比如，`int globalVar;` 可能会被固定分配在 `DS:[1234H]`。因此，程序中所有对 `globalVar` 的访问，都会被编译成 `MOV [1234H], ...` 这样的"直接寻址"指令。

2. **寄存器间接寻址**：操作数的偏移量（EA）存放在一个寄存器中。

在 `EA = 基址 + 变址 + 位移量` 公式中，我们只使用“基址”或“变址”。

> [!note] 案例分析 (MOV AX, [BX])
>
> 假设 `(DS) = 5000H`，并且我们**提前已经把 `1234H` 这个值存入了 `BX` 寄存器**中（比如通过 `MOV BX, 1234H`）。
>
> ![alt text](image-27.png)
>
> CPU执行 `MOV AX, [BX]`：
>
> - **第1步：计算16位有效地址 (EA)**
>
>   - 寻址方式是"寄存器间接寻址"。CPU去读取 `BX` 寄存器的内容。
>   - `EA = (BX) = 1234H`
>
> - **第2步：计算20位物理地址**
>
>   - CPU检查指令，发现使用的是 `BX` 寄存器（而不是`BP`）。按照**默认规则**，CPU自动选择**数据段寄存器 (DS)**。
>
>   - `物理地址 = (DS) * 16 + EA = 50000H + 1234H = 51234H`
> - **结果**：CPU同样去`51234H`取到了`6789H`放入`AX`。

3. **寄存器相对寻址**：`EA（偏移量）= 基址/变址寄存器 + 位移量`。

> [!note] 案例分析：MOV AX, [BX+1000H]
>
> ![alt text](image-28.png)
>
> - **第1步：计算16位有效地址 (EA)**
>
>   - `EA = (BX) + 1000H = 1234H + 1000H = 2234H`
>
> - **第2步：计算20位物理地址**
>
>   - CPU检查到EA的计算使用了`BX`（而不是`BP`）。按照**默认规则**，CPU自动选择**数据段 (DS)**。
>   - `物理地址 = (DS) * 16 + EA = 50000H + 2234H = 52234H`

> [!tip] 拓展（C3-4）:
>
> "寄存器相对寻址"是高级语言（如C/C++）实现 `struct` (结构体) 或 `class` (类) 访问的硬件基石。
>
> 假设你用C++定义了一个结构体：
>
> ```cpp
> struct Employee {
>     int id;       // 偏移量 0
>     char name[8]; // 偏移量 4
>     long salary;  // 偏移量 12
> };
> ```
>
> 当你创建一个指向这个结构体的指针 `Employee* p;` 时，编译器可能会把这个指针 `p` 的值（即`Employee`对象的起始地址）存放在 `EBX` 寄存器中。
>
> 执行 `long s = p->salary;` 这句代码时，编译器如何找到`salary`？
>
> `salary` 存放在结构体**起始地址偏移12个字节**的地方。编译器会生成这样的汇编指令： `MOV EAX, [EBX + 12]`

4. **基址变址寻址**：`EA = (BX 或 BP) + (SI 或 DI)`

![alt text](image-29.png)
5. **相对基址变址寻址**(16位寻址的“完全体”)：`EA（偏移量）= 基址 + 变址 + 位移量`。

这是我们在8086时代能用到的**最复杂、最灵活**的内存寻址方式。

> [!tip] 拓展（C3-5）：结构体数组
>
> 假设有一个C++结构体数组：
>
> ```cpp
> struct Employee {
>     int id;       // 偏移量 0
>     long salary;  // 偏移量 2 (假设)
>     char name[8]; // 偏移量 6 (假设)
> };
> Employee emp_array[10];
> int i = 3;
> char c = emp_array[i].name[2]; // 取第3个员工的名字的第2个字母
> ```
>
> **编译器生成的汇编指令** (简化版)：
>
> - `MOV BX, offset emp_array ; BX = 数组基地址` ，
> - `MOV SI, i ; SI = 索引 i` ，
> - `IMUL SI, sizeof(Employee) ; SI = i * 结构体大小` ，
> - `MOV AL, [BX + SI + 8]`

###### **I/O 端口寻址**

用于和**外部硬件**（键盘、鼠标、显卡、网卡）通信。

- 外围设备（硬件）通过“锁存器”或“寄存器”与CPU通信，这些寄存器就叫**端口 (Port)**。

- 为了管理这些端口，每个端口都被分配了一个**端口地址**。

- 80x86系统有一个**独立**的I/O地址空间，大小为64K（0 ~ 65535），即16位地址。

CPU访问I/O端口，**只能**使用两条专属指令：**`IN`** (输入) 和 **`OUT`** (输出)。根据端口地址的写法，又分为两种：

1. **直接端口寻址 (Direct Port Addressing)**：端口地址是一个**8位的常数**，直接写在指令里。

> [!note] 案例分析
>
> - **例1: `IN AL, 10H`**
>
>   - 含义：从`10H`号端口，读取8位数据，存入`AL`寄存器。
>
> - **例2: `OUT 20H, AX`**
>
>   - 含义：将`AX`寄存器（16位）的内容，发送到`20H`号端口。
>
>   - **细节**：这是一个16位操作。硬件会自动将其拆分为两次8位操作：
>
>         1. `AL` (低8位) 的值被发送到 **`20H`** 端口。
>
>         2. `AH` (高8位) 的值被发送到 **`21H`** 端口。
>
> - **例3: `IN EAX, 20H`**
>
>   - 32位操作，同理：
>
>     - `20H`端口 $\to$ `AL`
>
>     - `21H`端口 $\to$ `AH`
>
>     - `22H`端口 $\to$ `EAX`的高16-23位
>
>     - `23H`端口 $\to$ `EAX`的高24-31位
>
> - **局限**：这种方式只能访问地址在 `0 ~ 255` 之间的端口。

2. **间接端口寻址 (Indirect Port Addressing)**：端口地址为16位（0 ~ 0FFFFH），必须先存入`DX`寄存器。

为了能访问全部64K个端口，CPU规定，端口地址必须**间接**地通过 **`DX` 寄存器** 传递。

> [!note] 案例分析
>
> - **例1: `MOV DX, 1000H`** $\to$ `OUT DX, AL`
>
>   - 含义：将`1000H`（一个16位地址）先装入`DX`。
>
>   - 然后执行`OUT DX, AL`，CPU会读取`DX`的值（`1000H`），并将`AL`的数据发送到`1000H`号端口。
>
> - **例2: `IN AX, DX`**
>
>   - 含义：从`DX`寄存器所指向的端口（假设是`1000H`）读取16位数据。
>
>   - 硬件会自动：
>
>         1. 从 **`1000H`** 端口读数据 $\to$ `AL`。
>
>         2. 从 **`1001H`** 端口读数据 $\to$ `AH`。

> [!tip] 拓展（C3-6）
>
> - **DOS 时代 vs. 现代OS**
>
>   - 在古老的DOS时代，程序员可以"为所欲为"。你可以直接写`IN AL, 60H`来**直接读取键盘**的按键码，或者`OUT`指令去控制**PC喇叭**发声。
>
> - **特权指令 (Privileged Instructions)**
>
>   - 在现代操作系统（Windows, Linux, macOS）中，`IN` 和 `OUT` 是**特权指令**。
>   - 你的应用程序（如Word、Chrome）是运行在**低特权级（Ring 3）的。如果它们试图执行`IN`或`OUT`，CPU会立刻触发一个"通用保护异常" (GPF)**，操作系统会立即**强行关闭**这个程序。
>   - **原因：** 为了保护硬件。如果任何程序都能随意访问硬盘端口，它就能绕过文件系统，窃取或销毁所有数据。
>   - 只有运行在**最高特权级（Ring 0）的操作系统内核 (Kernel)** 和 **设备驱动程序 (Drivers)** 才有权执行`IN`和`OUT`。当你的键盘驱动需要读取按键时，是它（在Ring 0）替你执行了`IN AL, 60H`。
>
> - **现代趋势：MMIO (内存映射I/O)**
>
>   - I/O端口寻址（称为"Port-Mapped I/O, PMIO"）在x86上是历史遗留。
>   - 现代架构（如ARM，用于所有手机）以及现代x86上的新设备（如PCIe显卡），更喜欢使用**内存映射I/O (MMIO)**。
>   - MMIO的思路是：**不使用"平行世界"**，而是将硬件的"端口"**映射**到"主内存"地址空间中的某一块（通常在很高的地址）。
>   - 于是，CPU不再需要`IN/OUT`指令，而是用一条**普通的`MOV`指令**（如 `MOV [F8000100H], EAX`）就能和硬件通信。这更统一，也更高效。

#### 80x86 指令系统

##### 数据传送类 (Data Transfer)

> [!note]
>
> | 类别 | 指令 | 功能描述 | 工业应用/特点 |
> |------|------|----------|---------------|
> | **通用数据传送指令** | MOV | 数据传送，相当于高级语言的赋值操作 | 最基础、最常见的指令，`MOV AX, BX` 等同于 `AX = BX;` |
> | | `MOVSX` / `MOVZX` | 带符号/零扩展的数据传送 | **处理C/C++类型转换的关键**：<br>`MOVZX`：零扩展，用于无符号数<br>`MOVSX`：符号扩展，用于有符号数 |
> | | `PUSH` / `POP` | 压栈/出栈操作 | **函数调用的核心**：<br>保存返回地址、寄存器<br>实现后进先出(LIFO)的堆栈操作 |
> | | `PUSHA(D)` / `POPA(D)` | 压入/弹出所有通用寄存器 | 操作系统上下文切换的基石，用于保存和恢复程序"工作现场" |
> | | `XCHG` | 交换两个操作数的值 | 配合LOCK前缀实现原子操作和互斥锁(Mutex)的关键指令 |
> | | `XLAT` | 查表转换指令 | 专用硬件查表指令，用于ASCII码转换等场景 |
> | **目标地址传送指令** | `LEA` | 加载有效地址 | **C/C++指针和数学运算**：<br>获取指针地址：`p = &var;`<br>快速数学运算，比MUL指令更快 |
> | | `LDS, LES, LFS`... | 加载段地址 | 老式分段内存模型使用，现代64位扁平内存模型中已淘汰 |
> | **标志位传送指令** | `LAHF / SAHF` | 标志寄存器低8位传送 | 保存和恢复标志寄存器的部分状态 |
> | | `PUSHF(D) / POPF(D)` | 标志寄存器压栈/出栈 | 函数调用中保护标志位状态，避免被函数体操作污染 |
> | **输入输出指令** | `IN / OUT` | I/O端口通信 | 现代操作系统中为Ring 0特权指令：<br>应用程序无权直接使用<br>只有设备驱动程序可执行 |

###### `MOV` (Move) 指令

构成了所有程序的基础，在高级语言（如C/C++）中等同于 **”赋值“** 操作符。

- **指令格式**: `MOV 目的操作数, 源操作数`

- **指令作用**: 将“源操作数”的**副本**，传送到“目的操作数”的地址。

>[!warning] 澄清
>`MOV` (Move) 这个词其实有误导性。它并不是“移动”，而是“**复制**”。执行 `MOV AX, BX` 后，`BX` 的内容**保持不变**。

- **指令用法**: 它可以在字节(8位)、字(16位)或双字(32位)等级上操作。

![alt text](image-30.png)
> [!note] 路径 ①：通用寄存器 $\longleftrightarrow$ 通用寄存器
>
> - **例**: `MOV AL, BL` / `MOV CX, DX`
>
> - **最快**的`MOV`操作没有之一。数据完全在CPU核心内部流动，不涉及任何外部总线或内存访问。
>
> - C/C++编译器在进行代码优化时，最核心的目标就是尽可能地将变量（尤其是循环变量）保存在寄存器中，让所有操作都变成这种寄存器之间的传送，从而实现最高性能。

> [!note] 路径 ② & ④：段寄存器 $\longleftrightarrow$ 通用寄存器 或 存储器
>
> - **例**: `MOV BX, CS` / `MOV DS, [SI]`
>
> - `CS`, `DS`, `SS`, `ES` 这些段寄存器非常特殊，它们掌管着内存寻址的"街道名称"。我们必须有办法设置它们。
>
> - **路径**: 数据**可以从**"通用寄存器/存储器"**流向**"段寄存器"，或者**从**"段寄存器"**流向**"通用寄存器/存储器"。
>
> - **规则**:
>
>     1. `CS`（代码段）**不能作为目的操作数！** `MOV CS, AX` 是**非法**的。
>     2. **原因：** `CS` 和 `IP`（指令指针）是CPU的核心动力，指向下一条要执行的指令。不能用一个简单的数据传送指令去"篡改"发动机的指向。只能通过特定的**控制转移指令**（如`JMP FAR`或`CALL FAR`）来同时、安全地修改`CS`和`IP`。
>     3. 但是`CS` **可以作为源操作数**（如 `MOV BX, CS`），这允许程序查询自己当前的代码段地址。

> [!note] 路径 ③：通用寄存器 $\longleftrightarrow$ 存储器
>
> - **例**: `MOV [BP+DI], DL` / `MOV AX, [BX]`
>
> - **最常见**的`MOV`操作。几乎所有程序都在做这两件事：
>
>     1. **加载 (Load)**：`MOV AX, [BX]`，把内存中的数据，加载到寄存器中准备进行计算。
>
>     2. **存储 (Store)**：`MOV [BP+DI], DL`，把寄存器中的计算结果，存回到内存中。

> [!note] 路径 ⑤：立即数 $\longrightarrow$ 通用寄存器
>
> - **例**: `MOV BX, 34H` / `MOV ESI, 12345678H`
>
> - 给变量赋一个常量值。`34H` 这个立即数就编码在指令的机器码里。
>
> - 实际编译器中，`int i = 123;` 几乎100%会被编译器翻译成 `MOV EAX, 123`。

> [!note] 路径 ⑥：立即数 $\longrightarrow$ 存储器
>
> - **例**: `MOV BYTE PTR [BX], 12H`
>
> - 把常量（`12H`）直接存入一个内存地址（`[BX]`）。

> [!danger] `PTR`（**`Pointer`**） 关键字说明
>
> - **`xxxx PTR` 关键字**：**类型说明符**。两个词是一个整体，共同作用来​**​明确告知CPU如何解释后面的内存地址​**​。CPU需要知道是存一个字节(BYTE)、一个字(WORD)还是一个双字(DWORD)。
>
>   - `MOV [BX], 12H` 这条指令是**有歧义的**！CPU不知道是该存`0012H`（16位）还是`12H`（8位）。
>
>   - `MOV BYTE PTR [BX], 12H` 明确告诉CPU："只传送一个字节（`12H`）"。
>
>   - `MOV WORD PTR [BX], 12H` 明确告诉CPU："要传送一个字（`0012H`）"。

> [!warning] **禁令1：两个操作数的类型要一致**
>
> - `MOV CX, AL` 是**非法**的（16位 $\leftrightarrow$ 8位）。
>
> - **原因：** 硬件的数据通路是按8/16/32位造的。CPU没有设计"混合尺寸"的`MOV`电路。
>
> - **解决方案：** 使用专门的**符号/零扩展**指令，如：
>   - `MOVSX CX, AL` （​**​S​**​ign E​**​x​**​tend，它认为源操作数是一个​**​有符号数​**​（可以是正数或负数）。扩展时，它用源操作数的​**​最高位（符号位）​**​ 来填充所有新增加的高位）
>   - `MOVZX CX, AL`（​**​Z​**​ero E​**​x​**​tend，它认为源操作数是一个​**​无符号数​**​（只能是正数或零）。扩展非常简单粗暴：​**​无论源操作数是什么，所有新增加的高位一律补 0​**）

>[!warning] 禁令2：CS 不能作为目的操作数

> [!warning] 禁令3：IP 和 EFLAGS 不能作为操作数
>
> - **原因：** `IP`（指令指针）和`EFLAGS`（标志寄存器）是CPU的核心寄存器。它们被**所有**指令**隐含地**读取和修改（比如`ADD`会修改标志位，`JMP`会修改`IP`），但不能用`MOV`去**显式地**篡改它们。
>
> - **解决方案：** 使用专门的指令：`JMP/CALL` 来修改 `IP`；`PUSHF/POPF` 来存取 `EFLAGS`。

> [!warning] 禁令4：两个操作数不能都是内存操作数
>
> - `MOV [BX], [SI]` 是**绝对非法**的！
>
> - 这是x86（CISC）架构向RISC设计哲学的一种妥协。
>
>     1. **硬件复杂性**：一条指令同时访问两个内存地址，需要两套寻址电路，并且可能导致两次缓存未命中（Cache Miss），指令执行时间会变得极长且不可预测，这违背了流水线设计。
>
>     2. **"Load/Store"架构**：CPU的设计哲学是"计算在寄存器中进行"。
>
> - **必须**使用一个寄存器作为中转站：
>
>     1. `MOV AX, [SI]` (从仓库 $\to$ 口袋)
>
>     2. `MOV [BX], AX` (从口袋 $\to$ 仓库)
>
> - 当在C++中写 `a = b;`（a和b都是全局变量，都在内存中），编译器**自动**会生成上述两条`MOV`指令。

> [!warning] 禁令5 & 6：立即数不能作为目的；不能立即数 $\to$ 段寄存器
>
> - `MOV 1234H, AX` 是**非法**的。`1234H`是一个**值**，不是一个**存储位置**。
>
> - `MOV DS, 1234H` 也是**非法**的。
>
> - 出于**安全和设计考虑**。段寄存器太重要了，Intel强制必须"分两步走"，通过一个通用寄存器来中转，以防出错。
>
> - **解决方案：**
>
>     1. `MOV AX, 1234H`
>
>     2. `MOV DS, AX`
>

###### **`PUSH`** 和 **`POP`** ：对堆栈 (Stack)的操作

> [!note] 堆栈（Stack）
>
> ![alt text](image-31.png)
>
> 堆栈是内存中的一块特殊区域，采用“先进后出（LIFO）”原则。x86架构中，**栈底固定在高地址**，**栈顶在低地址**，数据入栈时地址递减。`SP`（栈顶指针）动态指向最新入栈数据。每次`PUSH`操作，数据压入更低地址，`SP`随之减少；`POP`则相反。此设计保证了数据后进先出，广泛用于函数调用、局部变量和中断处理等场景。

- **指令格式**:

 	- `PUSH <源操作数>` (16位或32位)
  		- `<源操作数>` 可以是：
      
      - **寄存器**：通用寄存器 (`AX`, `EBX`等) 或 段寄存器 (`DS`, `ES`等)。
          
      - **存储器**：内存中的一个值（如 `PUSH [BX+SI]`）。
          
      - **立即数 (386+ 优化)**：`PUSH 10`。在8086上这是非法的，你必须先 `MOV AX, 10` 再 `PUSH AX`。

 	- `POP <目的操作数>` (16位或32位)
  		- `<目的操作数>` 可以是：

      - **寄存器**：通用寄存器 (`AX`, `EBX`等) 或 段寄存器 (`DS`, `ES`等)。
          
      - **存储器**：内存中的一个位置（如 `POP [BX+SI]`）。

> [!note] 案例分析
>
> ![alt text](image-33.png)
>
> **PUSH AX**（入栈）：
>
> - `SP` 先减2，为16位数据腾出空间。
> - `AX` 的低字节(`AL`)写入低地址，高字节(`AH`)写入高地址（小端序）。
> - `SP` 指向新栈顶，`AX` 内容不变。
>
> **POP BX**（出栈）：
>
> - 从 `SP` 指向的地址依次读取2字节，分别装入 `BX` 的低/高字节。
> - `SP` 加2，指向下一个栈顶位置。
> - `BX` 获得栈顶数据，原数据被丢弃。

- **禁令1：操作数必须是 16/32 位**

  - **错误指令：`PUSH AL`**。

  - **原因：** `SP` 寄存器本身是16/32位的，硬件天生就是按“字 (Word)”或“双字 (DWord)”来对齐和移动的。不能只压入一个8位字节，会导致 `SP` 错位，整个堆栈结构都会被破坏。

- **禁令2：`PUSH` 立即数 (8086/8088 不支持)**

  - 在80286及以后的CPU上，`PUSH 5` 是合法的，CPU会将其自动扩展为16位（`0005H`）再压栈。

- **禁令3：`POP` 的目的不能是立即数或 `CS`**

  - `POP 1234H`：**非法**。`POP` 需要一个“存储位置”作为目的地，而 `1234H` 是一个“值”。

  - `POP CS`：**非法**！和 `MOV CS, ...` 是一个道理。`CS`只能通过 `JMP`, `CALL`, `RET` 等**控制转移指令**来修改，绝不能用数据传送指令来随意篡改。

> [!tip] 拓展（C3-7）：`PUSH`/`POP`与函数调用
>
> 在函数调用过程中，`PUSH` 和 `POP` 指令用于管理参数、返回地址和局部变量，确保调用与返回的正确性。典型流程如下：
>
> 1. **参数入栈**：调用前将参数（通常从右到左）依次`PUSH`到堆栈。
> 2. **保存返回地址**：`CALL`指令自动将返回地址`PUSH`到堆栈。
> 3. **保存和设置栈帧**：进入函数后，`PUSH EBP`保存上一级栈底指针，`MOV EBP, ESP`建立当前函数的栈帧，`SUB ESP, ...`为局部变量分配空间。
> 4. **函数返回**：`MOV ESP, EBP`释放局部变量，`POP EBP`恢复上一级栈底指针，`RET`自动`POP`返回地址并跳转回调用点。
>
> **安全提示**：由于堆栈同时存储数据和控制信息（如返回地址），若局部变量溢出可能覆盖返回地址，导致缓冲区溢出攻击风险。
###### `PUSHA` / `POPA` （A for All）—— 16位“全家桶” (286以上)

1. `PUSHA` (Push All)

- **指令格式**: `PUSHA` (无操作数)
    
- **功能**: 将**8个16位通用寄存器**一次性、按固定顺序压入堆栈。
    
    1. **顺序**: `AX`, `CX`, `DX`, `BX`, `SP`, `BP`, `SI`, `DI`
        
    2. **`SP`的特殊性**: `PUSHA`会压入**执行`PUSHA`指令之前**的`SP`的**原始值**。
        
    3. **堆栈变化**: 压入了8个16位的字（`word`），每个字占2字节。
        
        - 总共压入：`8 * 2 = 16` 字节。
            
        - `SP`指针最后会**一次性减 16** ( `SP = SP - 16` )。

2. `POPA` (Pop All)

- **指令格式**: `POPA` (无操作数)
    
- **功能**: `PUSHA`的逆操作，从堆栈中弹出8个字，依次放回8个寄存器。
	
    1. **顺序 (LIFO)**: 必须按`PUSH`的**相反顺序**弹出，以保证“后进先出”。
        
        - 顺序：`DI`, `SI`, `BP`, `SP`, `BX`, `DX`, `CX`, `AX`
            
    2. **旧`SP`值直接丢弃**
        
        - 当`POPA`执行到`SP`时，它会从堆栈中**弹出**那个旧的`SP`值，但**直接将其丢弃**，而**不是**试图将其加载回`SP`寄存器。
            
        - **原因：** `POPA`指令在执行过程中，`SP`寄存器本身正在被**连续地`+2, +2, +2...`**。如果它在中途试图恢复一个旧的`SP`值，整个堆栈就会立刻错乱。`POPA`指令的最终目的是把`SP`的值**增加16**，它通过“弹出并丢弃”这个动作来**保持弹出序列的完整性**，同时保证`SP`的正确移动。
            
    3. **堆栈变化**: 弹出了8个16位的字。
        
        - `SP`指针最后会**一次性加 16** ( `SP = SP + 16` )。

###### `PUSHAD` / `POPAD` （AD for All Doublewords)）—— 32位“全家桶” (386以上)

1. `PUSHAD` (Push All Doublewords)

- **指令格式**: `PUSHAD`
    
- **功能**: 将**8个32位通用寄存器** (`EAX`, `ECX`...）一次性压入堆栈。
	
    1. **顺序**: `EAX`, `ECX`, `EDX`, `EBX`, `ESP`, `EBP`, `ESI`, `EDI`
        
    2. **`ESP`的特殊性**: 同样，压入的是**执行`PUSHAD`指令之前**的`ESP`的**原始值**。
        
    3. **堆栈变化**: 压入了8个32位的双字（`dword`），每个双字占4字节。
        
        - 总共压入：`8 * 4 = 32` 字节。
            
        - `ESP`指针最后会**一次性减 32**。
            

2. `POPAD` (Pop All Doublewords)

- **指令格式**: `POPAD`
    
- **功能**: `PUSHAD`的逆操作。
	
    1. **顺序 (LIFO)**: `EDI`, `ESI`, `EBP`, `ESP`, `EBX`, `EDX`, `ECX`, `EAX`
        
    2. **旧`ESP`值直接丢弃**：**逻辑完全相同**。`POPAD`从堆栈中读取旧的`ESP`值，但**直接丢弃**。它只需要保证`ESP`的最终结果是**增加了32**即可。

> [!tip] 拓展（C3-8）：PUSHA(D)/POPA(D) 在上下文切换与函数调用中的作用
>
> `PUSHA(D)` 和 `POPA(D)` 主要用于**函数调用**和**操作系统上下文切换**。当操作系统需要切换任务（如从Word切换到Chrome），会用 `PUSHAD` 一次性保存当前任务的所有通用寄存器，确保CPU状态完整保留。切换到新任务时，再用 `POPAD` 恢复目标任务的寄存器内容，实现任务的无缝切换。这是多任务操作系统和中断处理的基础机制。

###### `XCHG` (Exchange) —— “原子交换”

`XCHG` 是一个功能非常直观的指令，作用类似于C++中的 `std::swap` 函数。

- **指令格式**: `XCHG 目的操作数, 源操作数`
    
- **指令作用**: 将“目的”和“源”的内容**互换**。
    
- **示例**: `XCHG AX, BX`
    
    - 执行前: `(AX)=1000H`, `(BX)=2000H`
        
    - 执行后: `(AX)=2000H`, `(BX)=1000H`
        
> [!warning] `XCHG` 的规矩和 `MOV` 非常相似：
>
> 1. **允许**: `寄存器, 寄存器`（如 `XCHG AX, BX`）
> 2. **允许**: `寄存器, 存储器`（如 `XCHG AX, [BX]`）
> 3. **禁止**: `存储器, 存储器`（如 `XCHG [SI], [DI]`）
>    - **原因**: 和 `MOV` 一样，x86硬件**没有**设计“内存到内存”的直接数据通路。你必须使用一个寄存器作为中转站。
> 4. **禁止**: `段寄存器`（如 `XCHG AX, DS`）
>    - **原因**: 段寄存器太重要了，不能参与这种“随意”的交换。
> 5. **禁止**: `立即数`（如 `XCHG AX, 1234H`）
>    - **原因**: 逻辑上不通。你可以把`AX`的值给`1234H`吗？`1234H`是一个**值**，不是一个**位置**。

> [!tip] 拓展（C3-9）：XCHG 的两大工程用法
>
> - `NOP`（空操作）
>   - `XCHG AX, AX` 的机器码为 `0x90`，即 `NOP`，等于**什么也没干 (No-Operation)**。因此，`0x90` (`NOP`) 就成了CPU的“官方”空操作指令，用于指令对齐、填充、调试/热补丁占位。
>
> - 原子锁（多核同步）
>   - 加 LOCK 前缀对内存做原子交换：`LOCK XCHG [g_Lock], EAX`。
>   - 约定 `g_Lock`：0 空闲，1 占用；线程先令 `EAX=1` 再执行交换。
>   - 结果：`EAX=0` 表示锁之前是“空闲”的，此次获取成功；`EAX=1` 表示**其他线程**已经把 `1` 放进去了，需等待自旋重试。
>   - `LOCK` 确保两个CPU核心（线程）不会同时修改同一个内存变量

###### `XLAT` (Translate) —— “硬件查表”

`XLAT` 是一条非常有“年代感”的指令。它没有显式的操作数，但**隐含地**使用 `AL` 和 `BX` 寄存器。

- **指令格式**: `XLAT TABLE` (后面的`TABLE`只是一个助记符，表示字节表的首地址，可以省略)。
    
- **指令作用**: 硬件实现的“**查表 (Table Lookup)**”指令。
    
- **隐含操作语句**: `AL = [ (DS) * 16 + (BX) + (AL) ]`

`XLAT` 实现了类似 Excel `VLOOKUP` 的查表功能：`BX` 指向表首地址，`AL` 作为索引，CPU自动取出 `BX+AL` 处的字节并写回 `AL`。常用于高效字节级数据转换。

> [!note] 四步用法
>
> 1. **建立字节表**：在内存中定义一个**字节 (DB)** 表格（长度不能超过256字节，因为`AL`是8位的索引）。
> 2. **`BX` $\gets$ 表首地址**：把这个表的起始地址装入`BX`寄存器。
> 3. **`AL` $\gets$ 表内序号**：把你想要查询的“索引”（从0开始）装入`AL`寄存器。
> 4. **执行 `XLAT`**。

> [!note] 示例：计算 `4` 的平方
>
> 1. **建立表**：`SQUARE_TABLE DB 00H, 01H, 04H, 09H, 10H...`
>     - (索引`0`的值是`0^2=0`)
>     - (索引`1`的值是`1^2=1`)
>     - (索引`2`的值是`2^2=4`)
>     - (索引`3`的值是`3^2=9`)
>     - (索引`4`的值是`4^2=16`，即`10H`)
>
> 2. **`BX` $\gets$ 表首地址**：
>     - `MOV BX, OFFSET SQUARE_TABLE` (或者 `LEA BX, SQUARE_TABLE`)
>     - `BX` 现在指向 `SQUARE_TABLE` 的第一个字节 (`00H`)。
>
> 3. **`AL` $\gets$ 表内序号**：
>     - `MOV AL, 4`
>     - `AL` 现在的值是 `04H`。
>
> 4. **执行 `XLAT`**：
>     - CPU在内部开始计算：
>         - `EA = (BX) + (AL)`
>         - `EA = (SQUARE_TABLE 的地址) + 4`
>     - CPU去这个新的`EA`地址取**1个字节**的数据。
>     - 那个地址上的数据正是 `10H`。
>     - CPU将 `10H` 这个值**放回 `AL` 寄存器**。
>
> - **结果**：`AL` 寄存器的值被**覆盖**，从 `04H` 变成了 `10H`（十进制的16）。我们成功地用“查表”代替了“计算”。

> [!tip] 拓展（C3-10）:`XLAT` 的历史与现代应用
>
> - **历史背景**：在8086时代，`MUL`（乘法）指令非常慢，而 `XLAT` 通过查表实现乘法等操作，速度更快，因此被广泛用于高效计算。
> - **现代用途**：随着硬件发展，`MUL` 已非常高效，`XLAT` 主要用于字节级查表转换，如 ASCII 与 EBCDIC 编码互转。只需建立256字节的转换表，`XLAT` 即可一条指令完成字符编码转换，适合高效数据“翻译”场景。

###### **`LEA` (Load Effective Address)**：加载有效地址

- **指令格式**: `LEA 目的操作数, 源操作数`
    
- **操作数规则**:
    
    - **目的操作数**：**必须**是一个通用寄存器（如`AX`, `EBX`）。
        
    - **源操作数**：**必须**是一个**内存操作数**（即用`[]`括起来的地址表达式）。

`LEA` 的**唯一**工作就是 **“计算”** 源操作数的**16位或32位有效地址 (EA)**（即那个“偏移地址”），然后把这个**地址数值本身**传送到目的寄存器中。

`LEA` **永远不会**去访问内存。它只在CPU内部做一次地址计算。

> [!note] 案例分析
>
> - **场景**: `(BX) = 1000H`, `(DI) = 0100H`
> - **指令**: `LEA BX, [BX+DI+0010H]`
> - **执行过程**:
>     1. CPU的**地址计算单元**开始工作。
>     2. 它读取源操作数的“配方”：`[BX+DI+0010H]`。
>     3. 它取`BX`的值（`1000H`）、`DI`的值（`0100H`）和立即数（`0010H`）。
>     4. **计算EA**: `EA = 1000H + 0100H + 0010H = 1110H`。
>     5. **传送结果**: CPU将这个计算结果 `1110H` 送入**目的寄存器`BX`**。
> - **执行后**: `(BX) = 1110H`。`BX` 寄存器**被自己的计算结果覆盖了**。

> [!tip] 拓展（C3-11）:LEA 指令的工程价值与优化应用
>
> `LEA`（加载有效地址）不仅是 C/C++ 指针取地址（`&`）操作的硬件基础，还被现代编译器广泛用于高效数学运算优化。其地址计算单元支持“**基址 + 变址*比例 + 位移量**”三操作数加法和乘法，常被用来替代较慢的 `ADD`、`MUL` 指令。例如：
>
> - 取数组元素地址：`LEA EAX, [my_array + ESI*4]`（等价于 `&my_array[i]`）
> - 实现加法：`LEA EAX, [EBX + 5]`（等价于 `EAX = EBX + 5`）
> - 实现乘法与加法：`LEA EAX, [EBX*4 + EBX]`（等价于 `EAX = EBX * 5`），`LEA EAX, [EBX*8 + EBX + 3]`（等价于 `EAX = EBX * 9 + 3`）
>
> 总结：`LEA` 既是指针操作的硬件支撑，也是编译器优化数学运算的利器，提升了代码执行效率。

###### `LDS` 及其兄弟指令：目标地址传送指令

- **指令格式**: `LDS 目的操作数, 存储器操作数`
    
- **指令作用**: `LDS` 的全称是 **Load pointer into DS**（加载指针到DS）。

> [!note] 远指针
> 
> 在8086的1MB（20位）地址空间中，逻辑地址由两部分组成：
> - 16位 段寄存器（如 DS）；
> - 16位 偏移（如 BX）。
> 
> 这类以 `段:偏移` 表示的指针称为“**远指针（Far Pointer）**”。物理地址通过段左移4位再加上偏移计算得出：physical = segment * 16 + offset，结果为20位物理地址（最大可达1MB）。

如果我们要从内存中加载一个“远指针”，我们必须同时更新**两个**寄存器：

```asm
MOV BX, [2000H]   ; 加载16位偏移量到 BX
MOV DS, [2002H]   ; 加载16位段地址到 DS
```

Intel的工程师设计了`LDS`，**用一条指令完成上述两项工作**。 `LDS` 指令会从“存储器操作数”所指向的内存地址，**连续读取32位（4字节）**：

1. 它把**前16位**（低16位）加载到“**目的操作数**”（一个16位通用寄存器）中，作为**偏移地址**。
    
2. 它把**后16位**（高16位）加载到 **`DS` 寄存器**中，作为**段地址**。

> [!note] 案例分析
>
> - 场景：执行前 `DS = 1000H`。指令 `LDS BX, [2000H]` 使用默认段寄存器 DS，物理地址 = `DS*16 + 2000H = 12000H`。
> - 内存（小端序）从物理地址 `12000H` 开始依次为：`34H`（偏移低字节）、`12H`（偏移高字节）、`00H`（段低字节）、`20H`（段高字节）。
> - **执行要点**：
>   1. 读取前两字节到 BX → `(BX) = 1234H`。  
>   2. 读取后两字节到 DS → `(DS) = 2000H`。
> - **结果**：`BX = 1234H`，`DS = 2000H`。
> - **等价说明**：功能等同于 `MOV BX, [2000H]` + `MOV DS, [2002H]`，但 `LDS` 用一条指令同时完成两者，语义明确且更高效。

**`LES` (Load pointer into ES)**

- 加载 `偏移量` $\to$ 目的寄存器

- 加载 `段地址` $\to$ **`ES` (附加段)**

- **工业应用**: `ES` 通常与`DI`配合用于字符串操作。`LES DI, [pString]` 是一条极高效的指令，它能一次性把一个“远指针”加载为 `ES:DI`，为接下来的字符串操作（如`MOVSB`）做好准备。

**`LFS` / `LGS` (Load pointer into FS / GS) (386以上)**
   
- 分别加载段地址到 `FS` 和 `GS`。

- 在现代64位操作系统（如Windows 64-bit）中，`GS` 寄存器（或`FS`，取决于OS）被““劫持”了，它不再指向内存段，而是指向一个操作系统内核设置的、**每个线程私有**的数据结构，称为**线程信息块 (Thread Information Block, TIB)**。

- 当你访问**线程局部存储 (Thread-Local Storage, TLS)**（比如C++中的 `__declspec(thread)` 变量）时，CPU就是在用`GS`寄存器寻址。`LGS` 指令就是操作系统在 **“上下文切换”**（从一个线程换到另一个线程）时，用来快速设置这个`GS`指针的关键指令。

**`LSS` (Load pointer into SS) (386以上)**
    
- 加载 `偏移量` $\to$ 目的寄存器（通常是`ESP`）

- 加载 `段地址` $\to$ **`SS` (堆栈段)**

- **工业应用**: `LSS` 是操作系统进行**任务（线程）切换**的**最关键指令之一**。

- **场景**: 每个任务（线程）都有自己**独立**的堆栈（由`SS:ESP`指向）。当操作系统要从任务A切换到任务B时，它必须：

	1. 保存任务A的 `SS` 和 `ESP`。
            
    2. 加载任务B的 `SS` 和 `ESP`。

    - `LSS ESP, [PointerToTaskBStack]` 这一条指令，就能**原子地、一步到位**地完成堆栈的切换，这对于多任务操作系统的稳定运行至关重要。

###### `LAHF`/`SAHF`/`PUSHF`/`POPF`：标志位传送指令

这组指令的**唯一目的**，就是让我们能够**显式地读取或修改** CPU的**标志寄存器 (FLAGS)**。`ADD`, `SUB`, `CMP` 等指令会**隐式地**改变标志位（如零标志ZF、进位标志CF）。而这组指令允许我们**手动**把这些标志“存储”或“写回”。

1. **`LAHF` (Load AH with Flags)**

- **指令格式**: `LAHF <无操作数>`

![alt text](image-34.png)

- **指令作用**：将`FLAGS`寄存器中**低8位**的值，**复制**到 `AH` 寄存器中。（并不是完整复制8位，而是按位对应的。它会把`SF` (符号), `ZF` (零), `AF` (辅助), `PF` (奇偶), `CF` (进位) 这5个最重要的状态标志，分别复制到`AH`的第 `7, 6, 4, 2, 0` 位。）

> [!note] 案例分析
> 
> ```
> C:\Users\ZHOUJI~1\ZJY>DEBUG
> -A
> 17D7:0100 LAHF
> 17D7:0101
> -R
> AX=0000 BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000
> DS=17D7 ES=17D7 SS=17D7 CS=17D7 IP=0100 NU UP EI PL NZ NA PO NC
> 17D7:0100 9F LAHF
> -T
> AX=0200 BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000
> DS=17D7 ES=17D7 SS=17D7 CS=17D7 IP=0101 NU UP EI PL NZ NA PO NC
> 17D7:0101 1E PUSH DS
> ```
> 
> **执行流程说明：**
> - 使用 `-A` 命令开始汇编，输入指令 `LAHF`（地址 17D7:0100）
> - 使用 `-R` 命令查看寄存器初始状态
> - 使用 `-T` 命令单步执行，执行 `LAHF` 指令后：
>   - AX 寄存器从 0000 变为 0200
>   - IP（指令指针）从 0100 前进到 0101
>   - 下一条待执行指令为 `PUSH DS`（机器码 1E）

2. `SAHF` **(Store AH with Flags)**

- **指令作用**：`LAHF`的**逆操作**。将`AH`寄存器中的值，**复制**回 `FLAGS` 寄存器的低8位，从而**一次性设置** `SF, ZF, AF, PF, CF` 这5个标志。
    
- 与`LAHF`一样，这也是一条**“历史遗留”**指令，现代编程中**几乎从不**使用。

3. `PUSHF` /`POPF`：**现代汇编中保存和恢复标志位的标准做法**

	- **`PUSHF` (Push the Flags)**
	    
	    - **指令作用**：将**整个16位**的`FLAGS`寄存器，**压入堆栈 (Stack)**。
	        
	    - **PPT 填空**：`SP的值减 2`。（因为压入了一个16位的字，占2字节）。
	        
	- **`POPF` (Pop the Flags)**
	    
	    - **指令作用**：从堆栈**顶部弹出一个16位的值**，将其**恢复**回`FLAGS`寄存器。
	        
	    - **PPT 填空**：`SP的值加 2`。（因为弹出了一个16位的字）。

###### `IN`/`OUT`：输入输出指令

这组指令用于CPU和**外部硬件**（如键盘、鼠标、网卡、串口）通信。

x86架构拥有两个“平行”的地址空间：

1. **内存地址空间**：我们所熟知的，用`MOV`指令访问。
    
2. **I/O 地址空间**：一个独立的、较小的地址空间（0 ~ 65535），专门用来“挂载”硬件设备。

`IN` 和 `OUT` 指令是访问**I/O地址空间**的**唯一**途径。

##### 算术运算类 (Arithmetic)

###### `ADD`/`ADC`/`INC`：加法指令

1. `ADD`

- **指令格式**：`ADD 目的操作数, 源操作数`
- **指令作用**：`目的操作数` $\leftarrow$ `目的操作数 + 源操作数`，运算结果会**覆盖**掉“目的操作数”中原来的值，“源操作数”的值**保持不变**。

寻址规则和 `MOV` 几乎一样，这体现了x86（CISC）架构的设计哲学：

- 当目的操作数为通用寄存器时，源操作数可以是通用寄存器、存储器操作数或者立即数；
- 当目的操作数是存储器操作数时，源操作数只能是通用寄存器或立即数。

`ADD` 指令会**全面更新**CPU的“状态指示灯板”——`FLAGS`寄存器。它会影响 **`OF, SF, ZF, AF, PF, CF`** 这6个核心的状态标志。

`ADD` 不仅仅是为了得到一个“和”，它更重要的作用是**通过设置这些标志，来为后续的 `if` 判断（条件跳转）提供依据**。

2. `ADC`**（Add with Carry）：带进位的加法**

- **指令格式**: `ADC 目的操作数, 源操作数` (语法规则与`ADD`完全相同)
    
- **指令作用**: `目的操作数` $\leftarrow$ `目的操作数 + 源操作数 + CF` 这里的 `CF`就是**进位标志 (Carry Flag, CF)**。`CF` 可能是 `0` 或 `1`。


`ADC` 是实现**大整数（多字节）运算**的唯一途径。

> [!note] 为什么需要 `ADC`（带进位加法）
>
> `ADC`（Add with Carry）用于多字节或多字加法。当处理器位数小于操作数位数（如16位CPU加32位数）时，需分多步相加。低位相加若产生进位，`CF` 标志会被置位。`ADC` 在高位相加时自动加上 `CF`，确保结果正确，是实现大整数加法的关键指令。

> [!note] 案例分析：16位CPU如何实现32位加法
>
> - **任务**: 计算 `DATA1 + DATA2`，其中 `DATA1 = 13579BDFH`，`DATA2 = 02468ACEH`。
>
> **步骤1：低16位相加**
>
> ```asm
> MOV AX, WORD PTR DATA1      ; AX = 9BDFH
> ADD AX, WORD PTR DATA2      ; AX = 9BDFH + 8ACEH = 126ADH
> MOV WORD PTR RESULT, AX     ; 结果低16位 = 26ADH，进位CF=1
> ```
>
> - 结果的低16位存入 `RESULT`，溢出的进位由 `CF` 标志保存。
>
> **步骤2：高16位带进位相加**
>
> ```asm
> MOV AX, WORD PTR DATA1+2    ; AX = 1357H
> ADC AX, WORD PTR DATA2+2    ; AX = 1357H + 0246H + CF = 159EH
> MOV WORD PTR RESULT+2, AX   ; 结果高16位 = 159EH
> ```
>
> - 利用 `ADC` 指令将高16位和进位一起相加，结果存入 `RESULT+2`。
>
> **最终结果**：`RESULT` 中为 `159E26ADH`，即两数之和。

这个 `ADD` $\to$ `ADC` $\to$ `ADC`... 的“**进位链**”是所有**高精度计算 (BigInt)** 库的底层原理。当在Python或Java中使用“大整数”计算一个1024位的加法时，CPU的底层就是在执行一个 `ADD` 和几十个 `ADC` 指令组成的循环。


3. `INC`**（Increment）：“精简的加1”**

- **指令格式**: `INC 目的操作数` (只有一个操作数)
    
- **指令作用**: `目的操作数 `$\leftarrow$` 目的操作数 + 1`

`INC` 指令会影响 `OF, SF, ZF, AF, PF`... **但它“不影响”CF (进位标志)！**

> [!note] 为什么 `INC` 不影响 `CF`
>
> `INC` 指令不会修改进位标志（CF），这是有意为之。虽然如 `(CX)=0FFFFH` 执行 `INC CX` 会溢出为 `0000H`，但 `CF` 保持原值，仅零标志（ZF）等被更新。这样设计便于将 `INC` 用作**循环计数或指针递增**，不影响多字节加法等需要进位链的场景，简化了循环和指针操作的实现。
> 
> Intel的工程师**故意**让`INC`不影响`CF`，就是为了让`INC`可以和`ADC`在同一个循环中**“和平共处”**。`INC` 专心做它的计数器，绝不“污染”`ADC` 赖以生存的`CF`标志。

###### 

> [!note] 补码加减法电路原理
>
> ![alt text](image-35.png)
>
> 现代ALU（算术逻辑单元）通过补码技术，用同一套加法电路实现加法和减法：
>
> - **加法（M=0）**：`B` 直接输入，初始进位 `C0=0`，电路执行 `A + B`。
> - **减法（M=1）**：`B` 取反（`NOT B`），初始进位 `C0=1`，电路执行 `A + (NOT B) + 1`，即 `A + [-B]`，等价于 `A - B`。
>
> 这样，CPU只需切换 `M` 信号即可在加法和减法间切换，无需专门的减法器。

1. `SUB` **(Subtract) —— 基础减法**

- **指令格式**：`SUB 目的操作数，源操作数`
- **指令作用**：`目的操作数` $\leftarrow$ `目的操作数 - 源操作数`

CPU看到 `SUB`，立刻将加减法电路的**控制信号 `M` 置为 `1`**，然后把“目的”和“源”送入电路的 `A` 和 `B` 端，和`ADD`一样，它会全面更新`OF, SF, ZF, AF, PF, CF`这6个标志。

- **`CF` (进位标志) 的特殊含义**：
    
    - 在`SUB`中，`CF`不再叫“进位标志”，而是叫“**借位标志 (Borrow Flag)**”。
        
    - **`CF = 1`** 意味着发生了借位（比如 `5 - 10`，不够减）。用于**无符号数**的比较。如果 `A - B` 导致 `CF=1`，就说明 `A < B`。

2. `SBB` **(Subtract with Borrow) —— “借位减法”**

- **指令格式**：`SBB 目的操作数，源操作数`
- **指令作用**：`目的操作数` $\leftarrow$ `目的操作数 - 源操作数 - CF`，也就是说，`SBB` 不仅执行 `A - B`，它还会**额外地再减去 `CF` (上一步的借位)**。

> [!note] 案例分析
>
> **任务**：在16位CPU上计算 `13579BDFH - 02468ACEH`
>
> 1. `MOV AX, 9BDFH`  
> 2. `SUB AX, 8ACEH`  
>    - 结果：`0F31H`，无借位（CF=0）
> 3. `MOV AX, 1357H`  
> 4. `SBB AX, 0246H`  
>    - 结果：`1111H`（因CF=0，无再借位）
>
> **最终结果**：`11110F31H`。  
> `SUB` 与 `SBB` 的配合实现了多字节减法的正确性，`SBB`自动处理低位运算产生的借位。

3. `CMP` **(Compare) —— “比较”** 

在所有减法指令中，`CMP`是对高级语言来说最重要的一条， 是所有 `if` 语句的硬件基础。

- **指令格式**：`CMP 目的操作数，源操作数`
- **指令作用**：`CMP` **假装**做了一次`SUB`运算（`目的 - 源`），然后**只更新标志寄存器**，但**不保存**那个减法的结果。

> [!tip] **`if` 语句的诞生**：
>
> **C++ 代码**: `if (a == b)`
>
> **汇编**:
>
> ```asm
> CMP a, b      ; 核心！
> JE  label_if_equal ; "Jump if Equal"
> ```
>
> `CMP` 执行 `a-b`。如果 `a` 等于 `b`，结果是 `0`。`CMP` 就会**点亮 `ZF` (零标志)**。`JE` 指令的任务就是检查 `ZF` 灯是否亮了，如果亮了，就跳转。
>
> **C++ 代码**: `if (a < b)` (假设是无符号数)
>
> **汇编**:
> ```asm
> CMP a, b
> JB  label_if_below ; "Jump if Below"
> ```
>
> `CMP` 执行 `a-b`。如果 `a` 小于 `b`，`a-b` 必然需要**借位**。`CMP` 就会**点亮 `CF` (借位标志)**。`JB` 指令就是检查 `CF` 灯是否亮了。

4. `DEC` **(Decrement)： “减1”**

- **指令格式**: `DEC 目的操作数` (只有一个操作数)

`DEC` 和 `INC` 一样，会影响 `OF, SF, ZF...`，但故意不影响 `CF` (进位/借位标志)

5. `NEG` **(Negate) ：“求补码”**

- **指令格式**: `NEG 目的操作数` (只有一个操作数)

- **指令作用**：`NEG` 对操作数**求补**。执行 `0 - 目的操作数`。在硬件上就是把 `A` 输入设为 `0`，`B` 输入设为“目的操作数”，然后将**控制信号 `M` 置为 `1`**（减法模式）。



##### 逻辑操作类 (Logical)

###### `AND`、`TEST`、`OR`、`XOR`、`NOT`：逻辑运算指令

###### `SHL`、`SHR`、`SAL`、`SAR`**：移位运算指令**

- **指令格式**:
    
    - `指令助记符 目的操作数, n`
        
    - `指令助记符 目的操作数, CL`
        
- **目的操作数**: 可以是8/16/32位的**通用寄存器**（如`AL`, `CX`, `EBX`），也可以是**存储器操作数**（如`[BX+SI]`）。
- **移位次数**:
	
	- **`n` (立即数)**：在代码中**写死**一个常数，比如 `SHL AX, 3`（左移3位）。
	    
	- **`CL` (寄存器)**：须使用`CL`寄存器（`CX`的低8位）来**动态地**指定移位次数。

> [!note] 次数限制说明
> - **8086系统的限制 (上古时代)**
>     
>     - **`n` 只能为 1**：`SHL AL, 1` 是合法的。但 `SHL AL, 2` 是**非法**的！这是早期为了节省晶体管而做的硬件简化。
>         
>     - 如果想在8086上移2位，**必须**使用`CL`：
>         
>         ```
>         MOV CL, 2
>         SHL AL, CL  ; 合法
>         ```
>         
> - **286以上系统 (现代)**
>     
>     - `n` 的限制被**取消**了。`SHL AL, 8` 这样的指令是完全合法的。
>         
> - **`CL` 是唯一的！**
>     
>     - 硬件电路被**硬编码**为只识别`CL`作为次数寄存器。
>         
>     - `SHL BL, CH` 是**非法**的。

![alt text](image-37.png)

1. `SHL` **(Shift Logical Left) - 逻辑左移**

**过程**:

1. **最高位 (MSB)**：被挤出去，进入 **`CF` 标志位**。

2. **最低位 (LSB)**：空出来的坑，用 **`0`** 填充。

3. 其他位：全部向左移动一个位置。

![alt text](image-38.png)

2. `SAL` **(Shift Arithmetic Left) - 算术左移**

**过程**:

1. **最高位 (MSB)**：被挤出去，“掉进” **`CF` 标志位**。

2. **最低位 (LSB)**：空出来的坑，用 **`0`** 填充。

`SAL` 和 `SHL` 的**硬件操作是完全相同的**！它们是同一条指令的两个不同“助记符”。

![alt text](image-39.png)

3. `SHR` **(Shift Logical Right) - 逻辑右移**

**过程**:

1. **最低位 (LSB)**：被挤出去，“掉进” **`CF` 标志位**。

2. **最高位 (MSB)**：空出来的坑，用 **`0`** 填充。

这种操作**只适用于无符号数**。因为最高位补0，所以结果永远是正数。

![alt text](image-40.png)

4. `SAR` **(Shift Arithmetic Right) - 算术右移**

**过程**:

1. **最低位 (LSB)**：被挤出去，“掉进” **`CF` 标志位**。

2. **最高位 (MSB)**：空出来的，用 **“原最高位”** 填充。

> [!note] SAR 算术右移的本质
> 
> - `SAR` 算术右移的关键在于**保持符号位不变**：右移时，最高位始终用原符号位填充，确保正数补0、负数补1，结果符号不变。
> - 适用于**带符号数**，常用于实现除以2的操作且保留正负号。

移位操作不仅仅是移动数据，它还会**全面更新**`FLAGS`寄存器，这对于`if`判断至关重要。

- **`CF` (进位标志)**
    
    - **规则**：`CF` **永远**等于 **“最后那个掉出去的比特位”**。
        
    - **用途**：可以用来逐位检查一个数。
        
- **`SF` (符号标志)** / **`ZF` (零标志)** / **`PF` (奇偶标志)**
    
    - **规则**：这三个标志会**根据移位后的“最终结果”** 来设置。
        
    - `SF=1`：如果结果是负数（最高位为1）。
        
    - `ZF=1`：如果结果是全0（`0000 0000`）。
        
    - `PF`：检查结果中`1`的个数（奇数个`1` $\to$ `PF=0`，偶数个`1` $\to$ `PF=1`）。
        
- **`AF` (辅助进位标志)**
    
    - **规则**：在移位操作中，`AF` 的状态是**未定义的**。
        
    - **结论**：不要在`SHL`/`SHR`之后依赖`AF`的值。
        
- **`OF` (溢出标志) **
    
    - **`OF` 的作用**：`OF=1` 意味着 **“带符号”** 运算的结果 **“符号反了”**（即正的变负，或负的变正）。
    
    - **`SAR`**：`OF` 永远为 `0`，不会导致溢出。
	
    -  **`SHR`**：对于（逻辑右移）指令，当且仅当移位次数为1时，CPU对 `OF` 标志的设置规则是：不进行任何复杂的“溢出”逻辑判断，**单纯地把移位前的那个符号位，复制到 `OF` 标志位里**。
    
    - **`SHL` / `SAL` (移位次数n=1时)**：
        
        - **规则**：`O = C ⊕ M`。`C`是进位标志(CF)，`M`是移位后的最高位。`⊕`是异或。
            
        - **解释**：`OF` 被置1，**当且仅当**“掉出去的位”和“新的符号位”**不相同**时。
            
            - 例1：`0100...` (正数) $\to$ `SHL` $\to$ `1000...` (负数)。**符号变了！`OF=1`**。
                
            - 例2：`1100...` (负数) $\to$ `SHL` $\to$ `1000...` (还是负数)。符号没变，`OF=0`。
                
            - 例3：`1000...` (负数) $\to$ `SHL` $\to$ `0000...` (正数)。**符号变了！`OF=1`**。
                
    - **`SHL` / `SAL` (移位次数n > 1时)**：
        
        - **规则**：`OF` 标志**未定义**。
            
        - 硬件只为`n=1`设计了溢出检测电路。

> [!note] 移位指令的高效乘除法应用
>
> 移位指令（`SHL`/`SAL`/`SHR`/`SAR`）本质上是**高效实现乘除法**的利器：
>
> - **左移一位**（`SHL`/`SAL`）：等价于乘以2
> - **右移一位**（`SHR`）：等价于**无符号数**除以2，`CF`保存被移出的最低位（即余数）
> - **算术右移**（`SAR`）：等价于**带符号数**除以2，自动保留符号
>
> 相比传统的`MUL`/`DIV`指令，移位操作极快（如8086上`SHL`仅需2个时钟周期，而`MUL`可能高达百余周期），在性能敏感场景下尤为重要。
>
> **示例：**
>
> - `SHL AL, 1`：无符号数 ×2
> - `SHR AL, 1`：无符号数 ÷2，`CF`为余数
> - `SAL AL, 1`：带符号数 ×2，`OF`指示溢出
> - `SAR AL, 1`：带符号数 ÷2，自动符号扩展

> [!tip] 编译器优化：移位与LEA替代乘法
>
> 现代编译器在遇到如 `int y = x * 10;` 这类常数乘法时，通常不会直接生成 `MUL` 指令，而是采用更高效的移位与加法组合。例如：
>
> ```asm
> MOV EAX, [x]
> MOV EBX, EAX
> SHL EAX, 3     ; x * 8
> SHL EBX, 1     ; x * 2
> ADD EAX, EBX   ; x * 10
> ```
>
> 更高级的优化会用 `LEA` 指令一步完成：`LEA EAX, [ESI*8 + ESI*2]`。这种“强度折减”优化大幅提升了乘法性能，是编译器生成高效代码的常见手段。

###### 循环移位指令 (Rotate)

语法规则和 `SHL`/`SHR` 完全一样

![alt text](image-41.png)

1. **`ROL` (Rotate Left) - 循环左移**

**过程**：最高位被挤出去，它**同时**去两个地方： a) 进入 **`CF` 标志位**（作为记录）。 b) “绕回来”，**填充**到**最低位 (LSB)** 的空位上。

![alt text](image-42.png)

2. **`ROR` (Rotate Right) - 循环右移**

**过程**：最低位被挤出去，它**同时**去两个地方： a) “掉进” **`CF` 标志位**（作为记录）。 b) “绕回来”，**填充**到**最高位 (MSB)** 的空位上。


##### 字符串操作类 (String)

###### `MOVS`、`LODS`、`STOS`、`CMPS`、`SCAS`、`INS`、`OUTS`



##### 控制转移类 (Control Transfer)

##### 处理器控制类 (Processor Control)
