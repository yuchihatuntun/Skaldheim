### CH-01 计算机系统漫游

- 计算机系统由**硬件**和**系统软件**共同工作，以运行应用程序；尽管系统的*具体实现方式*随时间变化，但*内在核心概念*保持稳定。
- 本书面向希望**深入理解系统组件（硬件、软件）如何工作**，以及这些组件如何影响“程序正确性、性能”，进而提升自身技能的程序员。若能掌握“底层系统及其对应用程序的影响”，读者有望成为顶尖开发者（“大牛”）。

### 2. 本书涵盖的实践技能与知识

书中会讲解多种核心技能与知识，包括：

- 避免“计算机数字表示方式”导致的异常数字错误；
- 优化C代码，充分利用现代处理器、存储器系统的设计；
- 理解编译器“过程调用”的实现逻辑，避免**缓冲区溢出错误**（这类错误会给网络、因特网软件带来严重安全漏洞）；
- 识别与解决“链接阶段”的常见（且令程序员困扰的）错误；
- 动手编写工具：如Unix shell、动态存储分配包，甚至Web服务器；
- 认识**并发**的价值与挑战（单芯片集成多处理器核后，并发的重要性愈发凸显）。

### 3. `hello`程序的核心作用

以Kernighan和Ritchie经典C教材中的**`hello`程序**（如图1-1所示代码）为示例：

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

尽管`hello`程序十分简单，但它的**运行过程需要系统各主要组件协同工作**。本书的关键目的之一，就是帮助读者理解：*当在系统上执行`hello`程序时，系统内部发生了什么，以及为什么会这样*。

### CH-02 信息的表示和处理

### CH-03 程序的机器级表示

计算机通过**机器代码**执行低级操作（处理数据、管理内存、读写存储/网络通信等）。

编译器（如GCC C语言编译器）会依据编程语言规则、目标机器指令集等，生成**汇编代码**（机器代码的“文本表示”，描述程序每条指令）；随后GCC调用汇编器、链接器，将汇编代码最终转换为可执行的机器代码。本章聚焦于“机器代码”及其人类可读形式——“汇编代码”的近距离分析。

> [!note]
> **高级语言与汇编编程的对比**
>
> - 高级语言（如C、Java）：**屏蔽机器级实现细节**，抽象级别高，开发效率更高、更可靠（编译器的“类型检查”能发现程序错误，保证数据处理的一致性）；且代码“与特定机器无关”，可在多类编程语言间移植。
> - 汇编代码编程：需程序员**手动指定低级计算指令**（类似早期计算时代的编程方式），抽象级别低，但更贴近机器硬件。

**x86 - 64的发展与特性**：

- **历史演变**：源于Intel 1978年的16位处理器，逐步扩展为32位、64位；AMD也对其发展有重要贡献。
- **特性特点**：因长期进化存在“历史遗留特性”，但文本聚焦**GCC和Linux实际使用的特性**，规避复杂/隐秘的部分。

> [!note]
> **IA32与x86-64的关系**
>
> IA32是x86-64的32位前身（1985年由Intel提出），曾是Intel主流机器语言。如今x86-64处理器可**向后兼容执行IA32程序**，因此许多应用仍基于IA32；且学习x86-64能轻松掌握IA32。

#### 历史观点

> [!note] x86架构发展简史
>
> **早期16位处理器（奠基阶段）**
>
> - **8086（1978年，29K晶体管）**：Intel第一代单芯片16位微处理器。变种**8088**（增加8位外部总线）成为“最初IBM个人计算机”的核心，配套MS-DOS系统；但地址空间有限（23位地址，寻址范围约1MB）。
> - **8087（1980年，45K晶体管）**：浮点协处理器，与8086/8088配合执行浮点指令，奠定x86系列的“x87浮点模型”。
>
> **32位架构过渡（突破寻址与系统支持）**
>
> - **80286（1982年，134K晶体管）**：增加多种寻址模式（部分后被废弃），是“IBM PC-AT”和早期MS Windows的硬件基础。
> - **i386（1985年，275K晶体管）**：首次将体系结构扩展到32位，引入“平坦寻址模式（flat addressing model）”——现代Linux、Windows系统均基于此模式；也是Intel首个全面支持Unix的处理器。
> - **i486（1989年，1.2M晶体管）**：性能提升，将“浮点单元”集成到处理器芯片，但指令集无明显革新。
>
> **Pentium系列（指令集与微体系革新）**
>
> - **Pentium（1993年，3.1M晶体管）**：性能优化，指令集小幅度扩展。
> - **PentiumPro（1995年，5.5M晶体管）**：引入“P6微体系结构”，新增“条件传送（conditional move）”指令。
> - **Pentium/MMX（1997年，4.5M晶体管）**：新增“整数向量指令”，支持1、2、4字节数据，向量总长64位。
> - **Pentium II（1997年，7M晶体管）**：P6微体系的延伸。
> - **Pentium III（1999年，8.2M晶体管）**：引入SSE指令集（处理整数/浮点向量，支持1、2、4字节数据，打包为128位向量）；后续版本因集成二级高速缓存，晶体管数增至24M。
> - **Pentium 4（2000年，42M晶体管）**：SSE扩展为SSE2，新增“双精度浮点数”等数据类型及144条新指令，使编译器可通过SSE（替代x87）编译浮点代码。
> - **Pentium 4E（2004年，125M晶体管）**：加入超线程技术（单处理器同时运行两个程序）；引入EM64T（Intel对“x86-64”64位扩展的实现，兼容IA32与64位）。
>
> **Core系列（多核与高级指令集）**
>
> - **Core 2（2006年，291M晶体管）**：回归类似P6的微体系，是Intel首个多核处理器（多处理器集成于单芯片），但不支持超线程。
> - **Core i7 Nehalem（2008年，781M晶体管）**：同时支持“超线程”与“多核”，每核可运行2个程序，单芯片最多4核。
> - **Core i7 Sandy Bridge（2011年，1.17G晶体管）**：引入AVX指令集（SSE的扩展，支持256位向量封装数据）。
> - **Core i7 Haswell（2013年，1.4G晶体管）**：AVX扩展为AVX2，增加更多指令与特性。

多年来，多家公司（**AMD为代表**）生产与Intel处理器**兼容的处理器**，可运行完全相同的机器级程序。

- AMD的市场策略：早期以“**性能稍低但价格更便宜**”为定位；2002年起竞争力跃升，不仅率先突破“1GHz时钟速度壁垒”，还**引领了IA32的64位扩展（即x86-64）**，该技术后来被广泛采用。

对于“GCC编译、Linux平台运行的程序”，我们通常无需关注x86的历史复杂性——因为大量早期特性已随技术迭代“过时”：

- 内存模型层面：8086的原始内存模型、80286对其的扩展，在**i386时代就已被淘汰**；
- 浮点指令层面：传统的**x87浮点指令**，在**SSE2指令集引入后也逐渐被替代**。

因此，尽管x86-64程序仍能看到“历史发展的痕迹”，但x86中许多晦涩难懂的旧特性，已不再出现在现代程序里。

#### 程序编码

以命令 `linux> gcc -Og -o p p1.c p2.c` 为例：

- `gcc`（或简写为`cc`，是Linux默认的C编译器）用于启动编译流程。
- 选项 `-Og`：让编译器生成**保留原始C代码整体结构**的优化机器码，适合**学习阶段**（因为更高级优化如`-O1`/`-O2`会让代码严重变形，难以和源码对应）。实际生产中，为追求性能，常使用`-O1`或`-O2`级别的优化。
- 选项 `-o p`：指定最终生成的可执行文件名为`p`。

GCC并非单一程序，而是调用“预处理→编译→汇编→链接”一整套工具链，将源码转化为可执行代码：

- **预处理**：C预处理器扩展源码，插入`#include`指定的头文件内容，展开`#define`声明的宏。
- **编译**：将预处理后的源码，生成每个源文件（如`p1.c`、`p2.c`）对应的**汇编代码文件**（如`p1.s`、`p2.s`）。
- **汇编**：汇编器将汇编代码（如`p1.s`）转化为**二进制目标代码文件**（如`p1.o`）。目标代码包含指令的二进制表示，但全局变量/函数的地址尚未最终填充。
- **链接**：链接器将多个目标文件（如`p1.o`、`p2.o`）与“库函数（如`printf`）的实现代码”合并，最终生成**可执行代码文件**（如`p`）。可执行代码是处理器能直接执行的机器码格式。

##### 机器级代码

计算机系统通过“抽象”隐藏实现细节，对机器级编程而言，有两类核心抽象：

- **指令集架构（ISA）**：定义机器级程序的格式与行为，包括“处理器状态”“指令格式”“每条指令对状态的影响”。像x86-64这类ISA，会把程序行为描述为**“指令顺序执行”**（一条执行完再执行下一条）；尽管实际处理器硬件会“并发执行多条指令”，但会通过技术手段保证“整体行为与ISA规定的顺序执行完全一致”。
- **虚拟内存抽象**：机器级程序使用的“内存地址”是**虚拟地址**，呈现出的内存模型像“一个极大的字节数组”；但实际内存系统是“硬件存储器 + 操作系统软件”的组合（第9章会详细讲解）。

> [!note] 编译与汇编的角色
>
> 编译过程中，编译器主要负责“将C语言的抽象执行模型”转换为“处理器能执行的基本指令”。而**汇编代码**是“接近机器码的中间表示”——和机器码的“二进制格式”相比，汇编代码用**可读性更好的文本格式**呈现。理解“汇编代码”以及“它与原始C代码的联系”，是理解“计算机如何执行程序”的关键一步。

### 3. x86-64的机器码与处理器状态

x86-64的机器码和原始C代码**差异极大**，一些对C程序员“隐藏的处理器状态”会暴露出来，比如：

- **程序计数器（PC）**：在x86-64中用`%rip`表示，作用是“给出将要执行的下一条指令在内存中的地址”。

简言之，这段文字为“理解机器级编程”铺垫基础：先通过“抽象模型”简化底层复杂度，再强调“编译→汇编”的桥梁作用，最后聚焦x86-64的具体硬件特性（如程序计数器的表现）。


### CH-04 处理器体系结构

1. 程序寄存器（RF）

| 列1       | 列2       | 列3       | 列4       |
|-----------|-----------|-----------|-----------|
| %rax      | %rsp      | %r8       | %r12      |
| %rcx      | %rbp      | %r9       | %r13      |
| %rdx      | %rsi      | %r10      | %r14      |
| %rbx      | %rdi      | %r11      |           |

`Y86-64`的15个**64位程序寄存器**，例如`%rax`、`%rcx`、`%rdx`、`%rbx`、`%rsp`、`%rbp`、`%rsi`、`%rdi`，以及`%r8`到`%r14`（省略了x86-64的`%r15`以简化编码）。

- 每个寄存器存储**64位的字**；
- 其中`%rsp`被专用作**栈指针**，用于入栈、出栈、函数调用和返回指令；
- 其他寄存器没有“固定含义或固定值”，可灵活用于数据操作。

### 2. 条件码（CC）

包含3个**1位的标志位**：`ZF`（零标志）、`SF`（符号标志）、`OF`（溢出标志）。
它们用于保存“最近一次算术或逻辑指令”对结果的影响信息（比如结果是否为零、是否为负、是否溢出），是后续条件分支等指令的判断依据。

### 3. 程序计数器（PC）

用于存放**当前正在执行指令的地址**，控制指令的顺序执行（或跳转后的执行）。

### 4. 程序状态（Stat）

用于指明**程序的运行状态**：是正常运行，还是发生了特殊事件（如异常）。

### 5. 内存（DMEM）

从概念上看，内存是一个**大的字节数组**，用于保存程序代码和数据。
Y86-64程序通过**虚拟地址**引用内存位置，由硬件（如MMU）和操作系统联合将虚拟地址翻译成“实际物理地址”，确定数据在内存中的真实位置（虚拟内存的细节会在后续章节展开，此处暂视为“单一的字节数组映像”）。

简言之，这部分内容定义了Y86-64指令集下，程序员（或编译出的机器代码）能直接访问、且会被指令操作的“处理器核心状态单元”，是理解指令如何与硬件状态交互的基础。
